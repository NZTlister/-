<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stable Galaxy Engine V4</title>
    <style>
        :root {
            --glass-bg: rgba(20, 20, 35, 0.6);
            --border: rgba(255, 255, 255, 0.1);
        }
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        
        #canvas-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; }

        /* 状态监控面板 */
        #debug-panel {
            position: absolute; top: 10px; left: 10px; z-index: 20;
            color: lime; font-family: monospace; font-size: 12px;
            background: rgba(0,0,0,0.8); padding: 5px 10px; pointer-events: none;
        }

        /* 摄像头小窗 */
        #camera-wrapper {
            position: absolute; top: 20px; right: 20px; width: 160px; height: 120px;
            z-index: 10; border-radius: 8px; overflow: hidden;
            border: 1px solid var(--border); background: #000;
            transition: opacity 0.3s;
        }
        #video-input { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }

        /* 控制栏 */
        #ui-panel {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            z-index: 10; display: flex; gap: 10px;
            background: var(--glass-bg); padding: 10px 20px; border-radius: 30px;
            backdrop-filter: blur(10px); border: 1px solid var(--border);
        }
        .btn {
            background: rgba(255,255,255,0.1); border: none; color: white;
            padding: 8px 16px; border-radius: 20px; cursor: pointer; transition: 0.2s;
        }
        .btn:hover, .btn.active { background: #00f2ff; color: #000; }
        
        /* 错误提示 */
        #error-msg {
            display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(255,0,0,0.8); color: white; padding: 20px; z-index: 100; text-align: center;
        }
    </style>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="debug-panel">FPS: Calculating... | AI: Waiting</div>
    <div id="canvas-container"></div>
    
    <div id="camera-wrapper">
        <video id="video-input" playsinline></video>
    </div>

    <div id="ui-panel">
        <button class="btn active" onclick="setShape('galaxy')">星系</button>
        <button class="btn" onclick="setShape('heart')">爱心</button>
        <button class="btn" onclick="setShape('vortex')">虫洞</button>
    </div>

    <div id="error-msg"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // 性能监控变量
        let lastTime = performance.now();
        let frames = 0;
        const debugPanel = document.getElementById('debug-panel');

        // --- 1. Three.js 初始化 ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.002);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 80;

        const renderer = new THREE.WebGLRenderer({ 
            antialias: false, // 关闭抗锯齿以提高性能
            powerPreference: "high-performance" 
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // 限制像素比
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;

        // --- 2. 优化后的粒子系统 ---
        // 关键调整：减少到 25,000 个粒子，保证流畅度
        const PARTICLE_COUNT = 25000; 
        
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const targets = new Float32Array(PARTICLE_COUNT * 3);
        const randoms = new Float32Array(PARTICLE_COUNT * 3);
        const colors = new Float32Array(PARTICLE_COUNT * 3);

        const color1 = new THREE.Color(0x00f2ff);
        const color2 = new THREE.Color(0xff0055);

        for(let i=0; i<PARTICLE_COUNT; i++) {
            positions[i*3] = (Math.random()-0.5)*200;
            positions[i*3+1] = (Math.random()-0.5)*200;
            positions[i*3+2] = (Math.random()-0.5)*200;
            
            randoms[i*3] = Math.random();
            randoms[i*3+1] = Math.random();
            randoms[i*3+2] = Math.random();
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('target', new THREE.BufferAttribute(targets, 3));
        geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uMorph: { value: 0 },
                uScale: { value: 1.0 },
                uRotZ: { value: 0.0 }
            },
            vertexShader: `
                uniform float uTime;
                uniform float uMorph;
                uniform float uScale;
                uniform float uRotZ;
                
                attribute vec3 target;
                attribute vec3 aRandom;
                attribute vec3 color;
                varying vec3 vColor;

                mat2 rotate(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }

                void main() {
                    vColor = color;
                    vec3 pos = mix(position, target, uMorph);
                    
                    // 简化的噪声运动，减少GPU计算
                    float t = uTime * 0.5;
                    pos.x += sin(t + aRandom.y * 10.0) * 0.5;
                    pos.y += cos(t + aRandom.z * 10.0) * 0.5;
                    
                    pos *= uScale;
                    pos.xy = rotate(uRotZ) * pos.xy;
                    
                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    gl_Position = projectionMatrix * mvPosition;
                    gl_PointSize = (3.0 * uScale + 1.0) * (60.0 / -mvPosition.z);
                }
            `,
            fragmentShader: `
                varying vec3 vColor;
                void main() {
                    vec2 uv = gl_PointCoord.xy - 0.5;
                    float d = length(uv);
                    if(d > 0.5) discard;
                    float glow = 1.0 - d * 2.0;
                    glow = pow(glow, 2.0);
                    gl_FragColor = vec4(vColor, glow);
                }
            `,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- 3. 形状生成 ---
        const shapes = {
            galaxy: (i) => {
                const angle = i * 0.01;
                const r = 10 + i * 0.002;
                const x = Math.cos(angle) * r;
                const z = Math.sin(angle) * r;
                const y = (Math.random()-0.5) * 10;
                // 颜色混插
                const c = new THREE.Color().lerpColors(color1, color2, i/PARTICLE_COUNT);
                colors[i*3] = c.r; colors[i*3+1] = c.g; colors[i*3+2] = c.b;
                return new THREE.Vector3(x, y, z);
            },
            heart: (i) => {
                const t = Math.random() * Math.PI * 2;
                const p = Math.random() * Math.PI;
                let x = 12 * Math.pow(Math.sin(p), 3) * Math.cos(t);
                let y = 12 * Math.cos(p) - 5*Math.cos(2*p) - 2*Math.cos(3*p) - Math.cos(4*p);
                let z = 12 * Math.pow(Math.sin(p), 3) * Math.sin(t) * 0.5;
                const c = new THREE.Color(0xff0055);
                colors[i*3] = c.r; colors[i*3+1] = c.g; colors[i*3+2] = c.b;
                return new THREE.Vector3(x,y,z);
            },
            vortex: (i) => {
                const r = (i / PARTICLE_COUNT) * 50;
                const theta = i * 0.1;
                const x = r * Math.cos(theta);
                const z = r * Math.sin(theta);
                const y = (Math.random()-0.5) * r;
                const c = new THREE.Color(0x00ff88);
                colors[i*3] = c.r; colors[i*3+1] = c.g; colors[i*3+2] = c.b;
                return new THREE.Vector3(x,y,z);
            }
        };

        let animateMorph = true;
        window.setShape = (name) => {
            const attr = geometry.attributes.target;
            const cAttr = geometry.attributes.color;
            for(let i=0; i<PARTICLE_COUNT; i++) {
                const v = shapes[name](i);
                attr.setXYZ(i, v.x, v.y, v.z);
            }
            attr.needsUpdate = true;
            cAttr.needsUpdate = true;
            material.uniforms.uMorph.value = 0;
            animateMorph = true;
        };
        // Init
        window.setShape('galaxy');


        // --- 4. 稳健的 AI 初始化 ---
        let targetScale = 1.0;
        let targetRotZ = 0.0;

        function onResults(results) {
            if(!results.multiHandLandmarks) return;
            
            const hands = results.multiHandLandmarks;
            debugPanel.innerText = `FPS: ${Math.round(frames)} | AI: Running | Hands: ${hands.length}`;

            if(hands.length === 2) {
                const h1 = hands[0][0];
                const h2 = hands[1][0];
                const dist = Math.hypot(h1.x - h2.x, h1.y - h2.y);
                targetScale = 0.5 + dist * 3.0;
                
                // 简单的旋转逻辑
                const dy = h1.y - h2.y;
                targetRotZ = dy * 2.0; 
                controls.autoRotate = false;
            } else {
                targetScale = 1.0;
                targetRotZ *= 0.9;
                controls.autoRotate = true;
            }
        }

        async function initAI() {
            try {
                const video = document.getElementById('video-input');
                const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
                
                // --- 关键优化：使用 Lite 模型 ---
                hands.setOptions({
                    maxNumHands: 2,
                    modelComplexity: 0, // 0 = Lite (最快), 1 = Full
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                hands.onResults(onResults);
        
                const cameraUtils = new Camera(video, {
                    onFrame: async () => { await hands.send({image: video}); },
                    width: 320, // 强制低分辨率
                    height: 240
                });
                
                await cameraUtils.start();
            } catch (error) {
                console.error(error);
                document.getElementById('error-msg').innerText = "AI 启动失败: " + error.message;
                document.getElementById('error-msg').style.display = 'block';
            }
        }

        // 延迟启动 AI，让页面先渲染出来
        setTimeout(initAI, 1000);


        // --- 5. 渲染循环 ---
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            
            // FPS 计算
            const now = performance.now();
            if (now - lastTime >= 1000) {
                frames = 0;
                lastTime = now;
            }
            frames++;

            const dt = clock.getDelta();
            material.uniforms.uTime.value = clock.getElapsedTime();

            // 平滑交互
            material.uniforms.uScale.value += (targetScale - material.uniforms.uScale.value) * 0.1;
            material.uniforms.uRotZ.value += (targetRotZ - material.uniforms.uRotZ.value) * 0.1;

            if(animateMorph) {
                material.uniforms.uMorph.value += dt * 0.5;
                if(material.uniforms.uMorph.value >= 1.0) {
                    material.uniforms.uMorph.value = 1.0;
                    animateMorph = false;
                    // Copy target to pos
                    const p = geometry.attributes.position.array;
                    const t = geometry.attributes.target.array;
                    for(let i=0; i<p.length; i++) p[i] = t[i];
                    geometry.attributes.position.needsUpdate = true;
                    material.uniforms.uMorph.value = 0.0;
                }
            }

            controls.update();
            renderer.render(scene, camera);
        }

        animate();
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
