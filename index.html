<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Romantic Particle System Pro (Fixed)</title>
    <style>
        :root {
            --glass-bg: rgba(255, 255, 255, 0.1);
            --glass-border: rgba(255, 255, 255, 0.25);
            --primary-color: #ff69b4;
        }
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', Roboto, sans-serif; }
        
        /* 3D å®¹å™¨ */
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; background: radial-gradient(circle at center, #1a1a2e 0%, #000000 100%); }

        /* UI é€šç”¨æ¯›ç»ç’ƒé£æ ¼ */
        .glass-panel {
            background: var(--glass-bg);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }

        /* æ‘„åƒå¤´çª—å£ - å¼ºåˆ¶æ˜¾ç¤ºä»¥ä¾¿è°ƒè¯• */
        #camera-container {
            position: absolute;
            top: 20px;
            right: 80px; 
            width: 160px;
            height: 120px;
            z-index: 10;
            border-radius: 16px;
            overflow: hidden;
            background: #000;
            border: 2px solid rgba(255,255,255,0.2);
        }
        
        #video-input { 
            width: 100%; height: 100%; object-fit: cover; 
            transform: scaleX(-1); /* é•œåƒ */
            display: block; /* ç¡®ä¿æ˜¾ç¤º */
        }

        /* åº•éƒ¨æ§åˆ¶é¢æ¿ */
        #ui-panel {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            padding: 12px 20px;
            border-radius: 40px;
            display: flex;
            gap: 12px;
            align-items: center;
        }
        
        .btn {
            background: rgba(255,255,255,0.05);
            border: 1px solid var(--glass-border);
            color: rgba(255,255,255,0.8);
            padding: 10px 18px;
            border-radius: 30px;
            cursor: pointer;
            transition: 0.2s;
            font-size: 15px;
            display: flex; align-items: center; gap: 6px;
            outline: none;
        }

        .btn:hover { background: rgba(255,255,255,0.2); color: white; transform: translateY(-2px); }
        .btn.active { background: var(--primary-color); border-color: var(--primary-color); color: white; box-shadow: 0 0 15px var(--primary-color); }
        
        .color-wrapper {
            width: 36px; height: 36px; border-radius: 50%; overflow: hidden; border: 2px solid rgba(255,255,255,0.5); cursor: pointer; transition: 0.3s;
        }
        input[type="color"] { border: none; width: 200%; height: 200%; cursor: pointer; background: none; padding: 0; transform: translate(-25%, -25%); }
        
        #fs-btn { 
            position: absolute; top: 20px; right: 20px; z-index: 11; 
            width: 44px; height: 44px; border-radius: 50%; font-size: 22px; 
            padding: 0; display: flex; justify-content: center; align-items: center;
            background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); color: white;
        }

        /* çŠ¶æ€æç¤º */
        #status-msg {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; z-index: 20; font-size: 16px;
            text-align: center; background: rgba(0,0,0,0.7); padding: 20px; border-radius: 10px;
            pointer-events: none;
        }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="canvas-container"></div>
    
    <div id="camera-container">
        <video id="video-input" playsinline></video>
    </div>
    
    <div id="status-msg">æ­£åœ¨è¿æ¥æ‘„åƒå¤´å¹¶ä¸‹è½½AIæ¨¡å‹...<br>è¯·ç¨å€™ï¼Œè¿™å¯èƒ½éœ€è¦å‡ ç§’é’Ÿ</div>

    <button id="fs-btn">â›¶</button>

    <div id="ui-panel" class="glass-panel">
        <button class="btn active" onclick="setShape('heart')">â¤ çˆ±å¿ƒ</button>
        <button class="btn" onclick="setShape('galaxy')">ğŸŒŒ æ˜Ÿç³»</button>
        <button class="btn" onclick="setShape('saturn')">ğŸª åœŸæ˜Ÿ</button>
        <button class="btn" onclick="setShape('flower')">ğŸŒ¸ èŠ±æœµ</button>
        <div style="width:1px; height:24px; background:rgba(255,255,255,0.2); margin: 0 5px;"></div>
        <div class="color-wrapper">
             <input type="color" id="color-picker" value="#ff69b4">
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- åˆå§‹åŒ– Three.js åœºæ™¯ ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.z = 45;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.8;

        // --- ç²’å­ç³»ç»Ÿè®¾ç½® ---
        const PARTICLE_COUNT = 40000;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const targets = new Float32Array(PARTICLE_COUNT * 3);
        const randoms = new Float32Array(PARTICLE_COUNT * 3);
        const colors = new Float32Array(PARTICLE_COUNT * 3);
        const baseColor = new THREE.Color('#ff69b4');

        for(let i=0; i<PARTICLE_COUNT; i++) {
            const i3 = i * 3;
            positions[i3] = (Math.random() - 0.5) * 150;
            positions[i3+1] = (Math.random() - 0.5) * 150;
            positions[i3+2] = (Math.random() - 0.5) * 150;
            randoms[i3] = Math.random(); 
            randoms[i3+1] = Math.random();
            randoms[i3+2] = Math.random();
            const c = baseColor.clone().offsetHSL(Math.random()*0.1-0.05, 0, 0);
            colors[i3] = c.r; colors[i3+1] = c.g; colors[i3+2] = c.b;
        }
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('target', new THREE.BufferAttribute(targets, 3));
        geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 3));
        geometry.setAttribute('aColor', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uGlobalColor: { value: new THREE.Color('#ff69b4') },
                uMorph: { value: 0 },
                uHandScale: { value: 1.0 },
                uHandDisplace: { value: 0.0 },
                uFlipRot: { value: 0.0 }
            },
            vertexShader: `
                uniform float uTime;
                uniform float uMorph;
                uniform float uHandScale;
                uniform float uHandDisplace;
                uniform float uFlipRot;
                attribute vec3 target;
                attribute vec3 aRandom;
                attribute vec3 aColor;
                varying vec3 vColor;
                varying float vAlpha;
                mat2 rotate2d(float _angle){ return mat2(cos(_angle),-sin(_angle),sin(_angle),cos(_angle)); }
                void main() {
                    vColor = aColor;
                    vec3 pos = mix(position, target, uMorph);
                    float timeScale = uTime * 1.5;
                    pos.x += sin(timeScale + aRandom.y * 6.28) * 0.3 * aRandom.x;
                    pos.y += cos(timeScale + aRandom.z * 6.28) * 0.3 * aRandom.y;
                    pos.z += sin(timeScale + aRandom.x * 6.28) * 0.3 * aRandom.z;
                    pos *= uHandScale;
                    float flipS = sin(uFlipRot);
                    float flipC = cos(uFlipRot);
                    mat2 flipMat = mat2(flipC, -flipS, flipS, flipC);
                    pos.xz = flipMat * pos.xz;
                    vec3 explosionDir = normalize(pos + vec3(0.001)); 
                    pos += explosionDir * uHandDisplace * 25.0;
                    pos.xz = rotate2d(uTime * 0.05 * (aRandom.x - 0.5)) * pos.xz;
                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    float baseSize = 3.5 * uHandScale + uHandDisplace * 2.0; 
                    gl_PointSize = baseSize * (35.0 / -mvPosition.z);
                    gl_Position = projectionMatrix * mvPosition;
                    vAlpha = smoothstep(100.0, 0.0, length(pos)) * 0.9 + 0.1;
                }
            `,
            fragmentShader: `
                uniform vec3 uGlobalColor;
                varying vec3 vColor;
                varying float vAlpha;
                void main() {
                    vec2 coord = gl_PointCoord - vec2(0.5);
                    float dist = length(coord);
                    float glow = 1.0 - smoothstep(0.0, 0.5, dist);
                    glow = pow(glow, 2.0); 
                    if (dist > 0.5) discard;
                    vec3 finalColor = mix(vColor, uGlobalColor, 0.7) + vec3(glow * 0.5);
                    gl_FragColor = vec4(finalColor, vAlpha * glow);
                }
            `,
            transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
        });
        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- å½¢çŠ¶é€»è¾‘ ---
        const shapes = {
            heart: (i) => {
                const theta = Math.random() * Math.PI, phi = Math.random() * Math.PI * 2;
                let x = 16 * Math.pow(Math.sin(theta), 3) * Math.cos(phi);
                let y = 13 * Math.cos(theta) - 5 * Math.cos(2*theta) - 2 * Math.cos(3*theta) - Math.cos(4*theta);
                let z = 16 * Math.pow(Math.sin(theta), 3) * Math.sin(phi) * 0.6;
                return new THREE.Vector3(x, y, z).multiplyScalar(0.9).addScaledVector(new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5), 1.5);
            },
            galaxy: (i, total) => {
                const spin = i/total * 5 * Math.PI * 2;
                const r = Math.pow(Math.random(), 1.5) * 35;
                return new THREE.Vector3(Math.cos(spin)*r + (Math.random()-0.5)*3, (Math.random()-0.5)*(r*0.1+2), Math.sin(spin)*r + (Math.random()-0.5)*3);
            },
            saturn: (i, total) => {
                if (i < total * 0.65) {
                    const r = 9, theta = Math.random()*Math.PI*2, phi = Math.acos((Math.random()*2)-1);
                    return new THREE.Vector3(r*Math.sin(phi)*Math.cos(theta), r*Math.sin(phi)*Math.sin(theta), r*Math.cos(phi));
                } else {
                    const a = Math.random()*Math.PI*2, r = 13 + Math.random()*9;
                    return new THREE.Vector3(Math.cos(a)*r, (Math.random()-0.5)*0.8, Math.sin(a)*r);
                }
            },
            flower: () => {
                const u = Math.random()*Math.PI, v = Math.random()*Math.PI*2, k = 3, r = 15*Math.sin(k*u);
                return new THREE.Vector3(r*Math.sin(u)*Math.cos(v), r*Math.sin(u)*Math.sin(v), r*Math.cos(u)).multiplyScalar(1.2);
            }
        };

        let animateMorph = true;
        window.setShape = (name) => {
            document.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
            event.currentTarget.classList.add('active');
            const targetAttr = geometry.attributes.target;
            for(let i=0; i<PARTICLE_COUNT; i++) {
                const v = shapes[name](i, PARTICLE_COUNT);
                targetAttr.setXYZ(i, v.x, v.y, v.z);
            }
            targetAttr.needsUpdate = true;
            material.uniforms.uMorph.value = 0;
            animateMorph = true;
        };
        // Init shape
        for(let i=0; i<PARTICLE_COUNT; i++) { const v = shapes.heart(i, PARTICLE_COUNT); geometry.attributes.target.setXYZ(i, v.x, v.y, v.z); }
        geometry.attributes.target.needsUpdate = true;

        // --- æ ¸å¿ƒï¼šMediaPipe ä¿®å¤ç‰ˆ ---
        let targetScale = 1.0, targetDisplace = 0.0, targetFlipRot = 0.0;
        let isCrossingHands = false;

        function onResults(results) {
            document.getElementById('status-msg').style.display = 'none'; // è¯†åˆ«æˆåŠŸï¼Œéšè—æç¤º
            
            const numHands = results.multiHandLandmarks.length;
            if (numHands === 2) {
                const [h1, h2] = results.multiHandLandmarks;
                const dist = Math.sqrt(Math.pow(h1[0].x-h2[0].x,2) + Math.pow(h1[0].y-h2[0].y,2) + Math.pow(h1[0].z-h2[0].z,2));
                targetScale = THREE.MathUtils.clamp(THREE.MathUtils.mapLinear(dist, 0.1, 0.6, 0.4, 2.2), 0.3, 2.5);
                
                const xDist = Math.abs(h1[0].x - h2[0].x);
                if (xDist < 0.1 && !isCrossingHands) {
                    isCrossingHands = true;
                    targetFlipRot = material.uniforms.uFlipRot.value + Math.PI;
                } else if (xDist > 0.2) isCrossingHands = false;
                
                targetDisplace = 0.0;
                controls.autoRotateSpeed = 1.2;
            } else if (numHands === 1) {
                const h = results.multiHandLandmarks[0];
                const pinch = Math.sqrt(Math.pow(h[4].x-h[8].x,2) + Math.pow(h[4].y-h[8].y,2));
                targetDisplace = pinch > 0.08 ? (pinch - 0.08) * 8.0 : 0.0;
                targetScale = 1.0;
                controls.autoRotateSpeed = 2.5;
            } else {
                targetScale = 1.0; targetDisplace = 0.0; controls.autoRotateSpeed = 0.8;
            }
        }

        // å¯åŠ¨æ‘„åƒå¤´é€»è¾‘
        const videoElement = document.getElementById('video-input');
        
        // ç¡®ä¿ window.Hands å­˜åœ¨ï¼ˆå¦‚æœè„šæœ¬åŠ è½½æ…¢ï¼Œè¿™é‡Œä¼šæŠ¥é”™ï¼Œä½†æˆ‘ä»¬æ”¾åœ¨headé‡ŒåŒæ­¥åŠ è½½äº†ï¼Œåº”è¯¥æ²¡äº‹ï¼‰
        if (window.Hands) {
            const hands = new window.Hands({locateFile: (file) => {
                // å…³é”®ä¿®å¤ï¼šå¼ºåˆ¶æŒ‡å‘ CDN è·¯å¾„ï¼Œé˜²æ­¢ 404
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});
            
            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            hands.onResults(onResults);

            if (window.Camera) {
                const cameraUtils = new window.Camera(videoElement, {
                    onFrame: async () => { await hands.send({image: videoElement}); },
                    width: 320, height: 240
                });
                cameraUtils.start().catch(err => {
                    document.getElementById('status-msg').innerText = "é”™è¯¯ï¼šæ— æ³•è®¿é—®æ‘„åƒå¤´ " + err;
                });
            }
        } else {
            document.getElementById('status-msg').innerText = "é”™è¯¯ï¼šAI æ¨¡å‹åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œ";
        }

        // --- å¾ªç¯ä¸äº‹ä»¶ ---
        document.getElementById('color-picker').addEventListener('input', (e) => material.uniforms.uGlobalColor.value.set(e.target.value));
        document.getElementById('fs-btn').addEventListener('click', () => !document.fullscreenElement ? document.documentElement.requestFullscreen() : document.exitFullscreen());
        window.addEventListener('resize', () => { camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight); });

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            material.uniforms.uTime.value = clock.getElapsedTime();
            
            const sensitivity = 0.35;
            material.uniforms.uHandScale.value += (targetScale - material.uniforms.uHandScale.value) * sensitivity;
            material.uniforms.uHandDisplace.value += (targetDisplace - material.uniforms.uHandDisplace.value) * sensitivity;
            material.uniforms.uFlipRot.value += (targetFlipRot - material.uniforms.uFlipRot.value) * 0.1;

            if (animateMorph) {
                material.uniforms.uMorph.value += dt * 0.7;
                if (material.uniforms.uMorph.value >= 1.0) {
                    material.uniforms.uMorph.value = 1.0;
                    animateMorph = false;
                    const p = geometry.attributes.position.array, t = geometry.attributes.target.array;
                    for(let i=0; i<p.length; i++) p[i] = t[i];
                    geometry.attributes.position.needsUpdate = true;
                    material.uniforms.uMorph.value = 0.0;
                }
            }
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
