<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galaxy Engine V5: Magic Finger</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        
        #canvas-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; }

        /* çŠ¶æ€æŒ‡ç¤º */
        #hud {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            color: rgba(0, 242, 255, 0.8); font-family: monospace; font-size: 14px;
            text-shadow: 0 0 5px cyan; pointer-events: none;
        }

        /* æ‘„åƒå¤´å°çª— (å³ä¸Šè§’) */
        #camera-wrapper {
            position: absolute; top: 20px; right: 20px; width: 160px; height: 120px;
            z-index: 10; border-radius: 12px; overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.1); background: #000;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            transition: opacity 0.5s;
        }
        #video-input { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
        
        /* äº¤äº’æç¤ºè¦†ç›–å±‚ */
        .overlay-icon {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 40px; color: white; opacity: 0; transition: opacity 0.3s;
            pointer-events: none; z-index: 20; text-shadow: 0 0 20px black;
        }

        /* åº•éƒ¨ UI */
        #ui-panel {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            z-index: 10; display: flex; gap: 15px;
            background: rgba(20, 20, 30, 0.6); padding: 12px 30px; border-radius: 40px;
            backdrop-filter: blur(15px); border: 1px solid rgba(255, 255, 255, 0.15);
        }
        .btn {
            background: transparent; border: 1px solid rgba(255,255,255,0.2); color: white;
            padding: 8px 20px; border-radius: 20px; cursor: pointer; transition: 0.3s;
            font-size: 14px; letter-spacing: 1px;
        }
        .btn:hover { background: rgba(255,255,255,0.2); transform: scale(1.05); }
        .btn.active { background: #00f2ff; color: #000; border-color: #00f2ff; box-shadow: 0 0 15px rgba(0,242,255,0.4); }

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 20px; z-index: 100;
        }
    </style>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="hud">
        MODE: INTERACTIVE<br>
        SPEED: <span id="speed-val">0</span>%
    </div>
    
    <div id="canvas-container"></div>
    
    <div id="icon-hand" class="overlay-icon">ğŸ‘†</div>
    <div id="icon-pinch" class="overlay-icon">ğŸ‘Œ</div>

    <div id="camera-wrapper">
        <video id="video-input" playsinline></video>
    </div>

    <div id="loading">æ­£åœ¨å¯åŠ¨é‡å­å¼•æ“...</div>

    <div id="ui-panel">
        <button class="btn active" onclick="setShape('galaxy')">æ˜Ÿç³»</button>
        <button class="btn" onclick="setShape('blackhole')">é»‘æ´</button>
        <button class="btn" onclick="setShape('sphere')">é‡å­çƒ</button>
        <button class="btn" onclick="setShape('cube')">çŸ©é˜µ</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- 1. åœºæ™¯é…ç½® ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.0015);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 100;

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        container.appendChild(renderer.domElement);

        // æˆ‘ä»¬è¿™æ¬¡å®Œå…¨è‡ªå·±æ¥ç®¡æ—‹è½¬é€»è¾‘ï¼Œä¸ä½¿ç”¨ OrbitControls çš„è‡ªåŠ¨æ—‹è½¬
        // è¿™æ ·æ‰èƒ½å®ç°â€œé£ŸæŒ‡æ‹¨åŠ¨â€çš„æ•ˆæœ

        // --- 2. ç²’å­ç³»ç»Ÿ (V5 Warp Engine) ---
        const PARTICLE_COUNT = 30000; 
        
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const targets = new Float32Array(PARTICLE_COUNT * 3);
        const colors = new Float32Array(PARTICLE_COUNT * 3);
        const sizes = new Float32Array(PARTICLE_COUNT);

        const colorCore = new THREE.Color(0x00f2ff); // é’
        const colorRim = new THREE.Color(0xff00aa);  // ç´«çº¢

        for(let i=0; i<PARTICLE_COUNT; i++) {
            positions[i*3] = (Math.random()-0.5)*200;
            positions[i*3+1] = (Math.random()-0.5)*200;
            positions[i*3+2] = (Math.random()-0.5)*200;
            sizes[i] = Math.random();
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('target', new THREE.BufferAttribute(targets, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1));

        const material = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uMorph: { value: 0 },
                uScale: { value: 1.0 },
                // æ—‹è½¬çŸ©é˜µç”± JS è®¡ç®—åä¼ å…¥
                uRotMatrix: { value: new THREE.Matrix4() },
                // é€Ÿåº¦å› å­ï¼Œç”¨äºæ‹‰ä¼¸æ•ˆæœ
                uSpeed: { value: 0.0 }
            },
            vertexShader: `
                uniform float uTime;
                uniform float uMorph;
                uniform float uScale;
                uniform mat4 uRotMatrix;
                uniform float uSpeed;
                
                attribute vec3 target;
                attribute vec3 color;
                attribute float aSize;
                
                varying vec3 vColor;
                varying float vAlpha;

                void main() {
                    vColor = color;
                    
                    // 1. Morph æ’å€¼
                    vec3 pos = mix(position, target, uMorph);
                    
                    // 2. è‡ªèº«æ—‹è½¬/å‘¼å¸
                    float t = uTime * 0.5;
                    float noise = sin(t + pos.x * 0.05) * 0.5;
                    pos += normalize(pos) * noise;

                    // 3. äº¤äº’ç¼©æ”¾
                    pos *= uScale;

                    // 4. æ ¸å¿ƒï¼šåº”ç”¨æ‰‹åŠ¿æ—‹è½¬çŸ©é˜µ
                    vec4 rotatedPos = uRotMatrix * vec4(pos, 1.0);
                    pos = rotatedPos.xyz;

                    // 5. Warp æ•ˆæœï¼šæ ¹æ®æ—‹è½¬é€Ÿåº¦æ²¿åˆ‡çº¿æ–¹å‘æ‹‰ä¼¸
                    // ç®€å•çš„æ¨¡æ‹Ÿï¼šç¦»ä¸­å¿ƒè¶Šè¿œï¼Œæ‹‰ä¼¸è¶Šæ˜æ˜¾
                    float dist = length(pos.xy);
                    // è¿™ç§ç®€å•çš„æ‹‰ä¼¸ä¼šäº§ç”Ÿä¸€ç§è¿åŠ¨æ¨¡ç³Šçš„æ„Ÿè§‰
                    pos.x += pos.y * uSpeed * 0.05 * dist * 0.1;
                    pos.y -= pos.x * uSpeed * 0.05 * dist * 0.1;

                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    gl_Position = projectionMatrix * mvPosition;
                    
                    // ç²’å­å¤§å°
                    gl_PointSize = (3.0 * aSize + 1.0) * uScale * (80.0 / -mvPosition.z);
                    
                    // é€Ÿåº¦è¶Šå¿«ï¼Œç²’å­è¶Šäº®
                    vAlpha = 1.0 + abs(uSpeed) * 2.0;
                }
            `,
            fragmentShader: `
                varying vec3 vColor;
                varying float vAlpha;
                void main() {
                    vec2 uv = gl_PointCoord.xy - 0.5;
                    float d = length(uv);
                    if(d > 0.5) discard;
                    
                    // äº®æ ¸
                    float glow = 1.0 - d * 2.0;
                    glow = pow(glow, 2.0);
                    
                    // æ··åˆé¢œè‰²ï¼Œé€Ÿåº¦å¿«æ—¶åç™½
                    vec3 finalColor = mix(vColor, vec3(1.0), clamp(vAlpha - 1.0, 0.0, 0.5));
                    
                    gl_FragColor = vec4(finalColor, glow);
                }
            `,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- 3. å½¢çŠ¶ç”Ÿæˆå™¨ ---
        const shapes = {
            galaxy: (i) => {
                const arms = 5;
                const spin = i % arms;
                const r = Math.pow(Math.random(), 1.5) * 70;
                const angle = spin * (Math.PI*2/arms) + r * 0.1;
                const x = Math.cos(angle) * r;
                const z = Math.sin(angle) * r;
                const y = (Math.random()-0.5) * (20 - r*0.2);
                
                const c = new THREE.Color().lerpColors(colorCore, colorRim, r/70);
                colors[i*3]=c.r; colors[i*3+1]=c.g; colors[i*3+2]=c.b;
                return new THREE.Vector3(x,y,z);
            },
            blackhole: (i) => {
                // å¸ç§¯ç›˜
                const r = 20 + Math.random() * 60;
                const angle = Math.random() * Math.PI * 2;
                // ç›˜é¢éå¸¸è–„
                const y = (Math.random()-0.5) * 2; 
                const x = Math.cos(angle) * r;
                const z = Math.sin(angle) * r;
                
                // è¶Šé è¿‘ä¸­å¿ƒè¶Šçº¢(çº¢ç§»)ï¼Œå¤–å›´æ˜¯å†·è‰²
                const c = new THREE.Color(0xff3300).lerp(new THREE.Color(0x0000ff), (r-20)/60);
                colors[i*3]=c.r; colors[i*3+1]=c.g; colors[i*3+2]=c.b;
                return new THREE.Vector3(x,y,z);
            },
            sphere: (i) => {
                const r = 50;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi);
                
                const c = new THREE.Color(0x00ff88);
                colors[i*3]=c.r; colors[i*3+1]=c.g; colors[i*3+2]=c.b;
                return new THREE.Vector3(x,y,z);
            },
            cube: (i) => {
                const size = 60;
                const x = (Math.random()-0.5) * size;
                const y = (Math.random()-0.5) * size;
                const z = (Math.random()-0.5) * size;
                const c = new THREE.Color(0xffffff);
                colors[i*3]=c.r; colors[i*3+1]=c.g; colors[i*3+2]=c.b;
                return new THREE.Vector3(x,y,z);
            }
        };

        let animateMorph = true;
        window.setShape = (name) => {
            document.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
            event.currentTarget.classList.add('active');
            
            const tAttr = geometry.attributes.target;
            const cAttr = geometry.attributes.color;
            for(let i=0; i<PARTICLE_COUNT; i++) {
                const v = shapes[name](i);
                tAttr.setXYZ(i, v.x, v.y, v.z);
            }
            tAttr.needsUpdate = true;
            cAttr.needsUpdate = true;
            material.uniforms.uMorph.value = 0;
            animateMorph = true;
        };
        window.setShape('galaxy');


        // --- 4. äº¤äº’é€»è¾‘ (ä¸Šå¸ä¹‹æŒ‡) ---
        
        // ç‰©ç†å˜é‡
        let currentRotation = new THREE.Quaternion(); // å½“å‰æ—‹è½¬å§¿æ€
        let targetRotationVelocity = { x: 0, y: 0 };  // ç›®æ ‡æ—‹è½¬é€Ÿåº¦
        let currentRotationVelocity = { x: 0, y: 0 }; // å½“å‰å¹³æ»‘åçš„é€Ÿåº¦
        
        let handScale = 1.0;
        let lastHandPos = null; // ä¸Šä¸€å¸§é£ŸæŒ‡åæ ‡
        
        // æƒ¯æ€§é˜»å°¼ (æ‘©æ“¦åŠ›)
        const DAMPING = 0.95; 

        function onResults(results) {
            const hands = results.multiHandLandmarks;
            
            // é‡ç½®ç›®æ ‡é€Ÿåº¦ï¼ˆæ¯å¸§é‡æ–°è®¡ç®—ï¼Œå¦‚æœæ²¡æœ‰æ‰‹å°±é æƒ¯æ€§ï¼‰
            let newVelX = 0;
            let newVelY = 0;
            let isInteracting = false;

            if (hands.length === 1) {
                // === å•æ‰‹ï¼šæ—‹è½¬æˆ–æåˆ ===
                const h = hands[0];
                const indexTip = h[8];
                const thumbTip = h[4];

                // 1. æ£€æŸ¥æ˜¯å¦æåˆ (Zoom)
                const pinchDist = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
                
                if (pinchDist < 0.08) {
                    // è§¦å‘æåˆï¼šé”å®šæ—‹è½¬ï¼Œåªåšç¼©æ”¾
                    document.getElementById('icon-pinch').style.opacity = 1;
                    document.getElementById('icon-hand').style.opacity = 0;
                    
                    // ç®€å•çš„ç¼©æ”¾é€»è¾‘ï¼šæå¾—è¶Šç´§è¶Šå°ï¼Ÿä¸ï¼Œæˆ‘ä»¬ç”¨æåˆæ—¶çš„æ‰‹åŠ¿ç§»åŠ¨æ¥ç¼©æ”¾æ›´å¥½
                    // è¿™é‡Œç®€åŒ–ï¼šæåˆæ—¶ï¼Œæ ¹æ®æ‰‹åœ¨Yè½´çš„ä½ç½®æ§åˆ¶å¤§å°
                    handScale = 0.5 + (1.0 - indexTip.y) * 2.0; 
                    lastHandPos = null; // æåˆæ—¶ä¸è®¡ç®—æ—‹è½¬
                    
                } else {
                    // è§¦å‘æ‹¨åŠ¨ï¼šé£ŸæŒ‡ç§»åŠ¨æ§åˆ¶æ—‹è½¬
                    document.getElementById('icon-pinch').style.opacity = 0;
                    document.getElementById('icon-hand').style.opacity = 1;
                    isInteracting = true;

                    if (lastHandPos) {
                        // è®¡ç®—æ‰‹æŒ‡ç§»åŠ¨çš„ Delta
                        // é•œåƒï¼šx å˜å¤§ä»£è¡¨å‘å·¦
                        const dx = (indexTip.x - lastHandPos.x) * 10.0; 
                        const dy = (indexTip.y - lastHandPos.y) * 10.0;
                        
                        // å°†æ‰‹æŒ‡ä½ç§»è½¬åŒ–ä¸ºæ—‹è½¬åŠ›
                        newVelX = dy;  // æ‰‹æŒ‡ä¸Šä¸‹åŠ¨ -> ç»• X è½´è½¬
                        newVelY = dx;  // æ‰‹æŒ‡å·¦å³åŠ¨ -> ç»• Y è½´è½¬
                        
                        // ç›´æ¥èµ‹äºˆé€Ÿåº¦ï¼Œæ‰‹åœåˆ™é€Ÿåœ (ä½†åœ¨ animate ä¸­ä¼šå¤„ç†æƒ¯æ€§)
                        targetRotationVelocity.x = newVelX;
                        targetRotationVelocity.y = newVelY;
                    }
                    lastHandPos = { x: indexTip.x, y: indexTip.y };
                }

            } else {
                // æ— æ‰‹åŠ¿
                lastHandPos = null;
                document.getElementById('icon-hand').style.opacity = 0;
                document.getElementById('icon-pinch').style.opacity = 0;
                // è®©å®ƒè‡ªåŠ¨ç¨å¾®è½¬ä¸€ç‚¹ï¼Œä¿æŒæ´»åŠ›
                targetRotationVelocity.y += 0.001; 
            }
        }

        // åˆå§‹åŒ– AI
        async function initAI() {
            try {
                const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
                hands.setOptions({
                    maxNumHands: 1, // ä¸“æ³¨å•æ‰‹æ€§èƒ½
                    modelComplexity: 0, // Lite æ¨¡å‹
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                hands.onResults(onResults);
                
                const video = document.getElementById('video-input');
                const cameraUtils = new Camera(video, {
                    onFrame: async () => { await hands.send({image: video}); },
                    width: 320, height: 240
                });
                await cameraUtils.start();
                document.getElementById('loading').style.display = 'none';
            } catch (e) {
                document.getElementById('loading').innerText = "å¯åŠ¨å¤±è´¥: " + e;
            }
        }
        setTimeout(initAI, 500);

        // --- 5. æ¸²æŸ“å¾ªç¯ (ç‰©ç†å¼•æ“) ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();

            material.uniforms.uTime.value = clock.getElapsedTime();

            // === ç‰©ç†æ¨¡æ‹Ÿæ ¸å¿ƒ ===
            
            // 1. æƒ¯æ€§æ’å€¼ï¼šå¦‚æœæ‰‹æ¾å¼€äº†ï¼Œé€Ÿåº¦ä¼šæ…¢æ…¢è¡°å‡ (Damping)
            if (!lastHandPos) {
                targetRotationVelocity.x *= DAMPING;
                targetRotationVelocity.y *= DAMPING;
            }

            // 2. å¹³æ»‘å½“å‰é€Ÿåº¦ (Lerp)
            currentRotationVelocity.x += (targetRotationVelocity.x - currentRotationVelocity.x) * 0.1;
            currentRotationVelocity.y += (targetRotationVelocity.y - currentRotationVelocity.y) * 0.1;

            // 3. åº”ç”¨æ—‹è½¬
            // æ„å»ºå››å…ƒæ•°å¢é‡
            const qx = new THREE.Quaternion();
            qx.setFromAxisAngle(new THREE.Vector3(1, 0, 0), currentRotationVelocity.x * 0.5);
            const qy = new THREE.Quaternion();
            qy.setFromAxisAngle(new THREE.Vector3(0, 1, 0), currentRotationVelocity.y * 0.5);
            
            // å åŠ æ—‹è½¬
            currentRotation.multiplyQuaternions(qy, currentRotation);
            currentRotation.multiplyQuaternions(qx, currentRotation);

            // 4. æ›´æ–° Shader çŸ©é˜µ
            const rotMatrix = new THREE.Matrix4();
            rotMatrix.makeRotationFromQuaternion(currentRotation);
            material.uniforms.uRotMatrix.value = rotMatrix;

            // 5. æ›´æ–°é€Ÿåº¦ç‰¹æ•ˆ (Warp Effect)
            const speed = Math.abs(currentRotationVelocity.x) + Math.abs(currentRotationVelocity.y);
            material.uniforms.uSpeed.value = speed * 10.0;
            document.getElementById('speed-val').innerText = Math.round(speed * 1000);

            // 6. ç¼©æ”¾å¹³æ»‘
            material.uniforms.uScale.value += (handScale - material.uniforms.uScale.value) * 0.1;

            // 7. Morph åŠ¨ç”»
            if (animateMorph) {
                material.uniforms.uMorph.value += dt * 0.5;
                if(material.uniforms.uMorph.value >= 1.0) {
                    material.uniforms.uMorph.value = 1.0;
                    animateMorph = false;
                    const p = geometry.attributes.position.array;
                    const t = geometry.attributes.target.array;
                    for(let i=0; i<p.length; i++) p[i] = t[i];
                    geometry.attributes.position.needsUpdate = true;
                    material.uniforms.uMorph.value = 0.0;
                }
            }

            renderer.render(scene, camera);
        }

        animate();
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
