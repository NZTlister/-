<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Gesture Particle System</title>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
  
  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: #000;
      overflow: hidden;
      font-family: sans-serif;
    }
    #container {
      position: relative;
      width: 100vw;
      height: 100vh;
      transform: scaleX(-1); /* 整体镜像 */
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
    /* 加载提示层（不做镜像，否则字是反的） */
    #loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      color: #00FF00;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
      pointer-events: none;
    }
    .spinner {
      border: 4px solid #333;
      border-top: 4px solid #00FF00;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
  </style>
</head>
<body>

  <div id="loading-overlay">
    <div class="spinner"></div>
    <h2 id="status-text">Initializing Camera & Model...</h2>
    <p style="color: #666; font-size: 14px; margin-top: 10px;">Please allow camera access when prompted.</p>
  </div>

  <div id="container">
    <video id="input_video" style="display: none;"></video>
    <canvas id="output_canvas"></canvas>
  </div>

<script>
const videoElement = document.getElementById('input_video');
const canvasElement = document.getElementById('output_canvas');
const ctx = canvasElement.getContext('2d');
const loadingOverlay = document.getElementById('loading-overlay');
const statusText = document.getElementById('status-text');

// 状态定义
const STATE_WAITING = 0;
const STATE_RUNNING = 1;
let gameState = STATE_WAITING;

// 调整尺寸
canvasElement.width = window.innerWidth;
canvasElement.height = window.innerHeight;
window.addEventListener('resize', () => {
  canvasElement.width = window.innerWidth;
  canvasElement.height = window.innerHeight;
});

// 粒子系统
let particles = [];
let forceDirection = 1;
let palmFacingCamera = true;
let targetX = 0, targetY = 0;
let isHandDetected = false;

// 粒子类
class Particle {
  constructor(w, h) {
    this.x = Math.random() * w;
    this.y = Math.random() * h;
    this.vx = (Math.random() - 0.5) * 4;
    this.vy = (Math.random() - 0.5) * 4;
    this.life = 1.0;
    this.r = 100 + Math.random() * 155;
    this.g = 200 + Math.random() * 55;
    this.b = 255;
    this.size = Math.random() * 3 + 2;
  }
  update(tx, ty, forceDir, hasTarget) {
    if (hasTarget) {
      let dx = tx - this.x;
      let dy = ty - this.y;
      let dist = Math.sqrt(dx * dx + dy * dy) + 0.1;
      let nx = dx / dist;
      let ny = dy / dist;
      let force = 0.5 * forceDir; 
      if (dist < 30) force *= 0.1;
      this.vx += nx * force;
      this.vy += ny * force;
    } else {
      this.vx += (Math.random() - 0.5) * 0.2;
      this.vy += (Math.random() - 0.5) * 0.2;
    }
    this.vx *= 0.95;
    this.vy *= 0.95;
    this.x += this.vx;
    this.y += this.vy;
    this.life -= 0.005;
  }
  draw(ctx) {
    if (this.life > 0) {
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.size, 0, 2 * Math.PI);
      ctx.fillStyle = `rgba(${this.r}, ${this.g}, ${this.b}, ${this.life})`;
      ctx.fill();
    }
  }
}

// GUI 绘制
function drawStartGUI() {
  ctx.save();
  ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
  ctx.fillRect(0, 0, canvasElement.width, canvasElement.height);
  
  // 反转文字
  ctx.translate(canvasElement.width, 0);
  ctx.scale(-1, 1);
  
  ctx.fillStyle = '#FFFFFF';
  ctx.font = 'bold 40px Arial';
  ctx.textAlign = 'center';
  ctx.fillText("GESTURE SYSTEM", canvasElement.width / 2, canvasElement.height / 2 - 50);
  ctx.fillStyle = '#00FFFF';
  ctx.font = '30px Arial';
  ctx.fillText("Raise Hand High to START", canvasElement.width / 2, canvasElement.height / 2 + 20);
  ctx.restore();
}

// 逻辑判断
function checkStartGesture(landmarks) {
  return landmarks[0].y < 0.3; 
}

function checkPalmOrientation(landmarks, handedness) {
  const idx_x = landmarks[5].x;
  const pinky_x = landmarks[17].x;
  let isFacing = false;
  if (handedness === 'Right') { 
     if (idx_x < pinky_x) isFacing = true;
  } else { 
     if (idx_x > pinky_x) isFacing = true;
  }
  return isFacing;
}

// MediaPipe 回调
function onResults(results) {
  // 隐藏 Loading
  if (loadingOverlay.style.display !== 'none') {
    loadingOverlay.style.display = 'none';
  }

  ctx.save();
  ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);
  ctx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

  const handsData = results.multiHandLandmarks;
  const handednessData = results.multiHandedness;
  isHandDetected = false;

  if (gameState === STATE_WAITING) {
    drawStartGUI();
    if (handsData && handsData.length > 0) {
      drawConnectors(ctx, handsData[0], HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
      if (checkStartGesture(handsData[0])) {
        gameState = STATE_RUNNING;
        for(let i=0; i<100; i++) particles.push(new Particle(canvasElement.width, canvasElement.height));
      }
    }
  } 
  else if (gameState === STATE_RUNNING) {
    if (handsData && handsData.length > 0) {
      isHandDetected = true;
      const landmarks = handsData[0];
      const handedness = handednessData[0].label;
      
      targetX = (landmarks[0].x + landmarks[9].x) / 2 * canvasElement.width;
      targetY = (landmarks[0].y + landmarks[9].y) / 2 * canvasElement.height;
      palmFacingCamera = checkPalmOrientation(landmarks, handedness);

      let statusColor = palmFacingCamera ? '#00FF00' : '#FF0000';
      let statusText = palmFacingCamera ? "Attract (Palm)" : "Repel (Back)";
      forceDirection = palmFacingCamera ? 1 : -1;

      ctx.beginPath();
      ctx.arc(targetX, targetY, 15, 0, 2 * Math.PI);
      ctx.fillStyle = statusColor;
      ctx.fill();

      // 文字回正
      ctx.save();
      ctx.translate(canvasElement.width, 0);
      ctx.scale(-1, 1);
      ctx.fillStyle = statusColor;
      ctx.font = "20px Arial";
      ctx.fillText(statusText, canvasElement.width - 200, 50);
      ctx.restore();
    }

    if (particles.length < 300) particles.push(new Particle(canvasElement.width, canvasElement.height));
    for (let i = particles.length - 1; i >= 0; i--) {
      let p = particles[i];
      p.update(targetX, targetY, forceDirection, isHandDetected);
      p.draw(ctx);
      if (p.life <= 0) particles.splice(i, 1);
    }
  }
  ctx.restore();
}

const hands = new Hands({locateFile: (file) => {
  return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
}});
hands.setOptions({
  maxNumHands: 1,
  modelComplexity: 1,
  minDetectionConfidence: 0.7,
  minTrackingConfidence: 0.7
});
hands.onResults(onResults);

const camera = new Camera(videoElement, {
  onFrame: async () => {
    await hands.send({image: videoElement});
  },
  width: 1280,
  height: 720
});

// 启动并捕获错误
statusText.innerText = "Requesting Camera...";
camera.start()
  .then(() => {
    statusText.innerText = "Loading AI Model...";
  })
  .catch(err => {
    console.error(err);
    statusText.innerText = "Camera Error: " + err.message;
    statusText.style.color = "red";
    // 提示用户必须使用服务器
    let hint = document.createElement("p");
    hint.innerHTML = "Did you open this file directly? <br> You MUST use a <b>Local Server</b> (localhost).<br>Direct file:// access is blocked by browsers.";
    hint.style.color = "white";
    loadingOverlay.appendChild(hint);
  });

</script>
</body>
</html>
