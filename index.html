<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Ultimate Dual-Hand Particles</title>
  
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
  
  <style>
    body {
      margin: 0; padding: 0; background-color: #000; overflow: hidden;
      font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      -webkit-user-select: none; user-select: none;
    }
    #container { position: relative; width: 100vw; height: 100vh; }
    canvas { display: block; width: 100%; height: 100%; object-fit: cover; }
    
    #loading-overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.95); color: #00FF00;
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      z-index: 100; text-align: center; padding: 20px;
    }
    .spinner {
      border: 4px solid rgba(0, 255, 0, 0.2); border-top: 4px solid #00FF00;
      border-radius: 50%; width: 50px; height: 50px;
      animation: spin 1s linear infinite; margin-bottom: 30px;
    }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
  </style>
</head>
<body>

  <div id="loading-overlay">
    <div class="spinner"></div>
    <h2 id="status-text">Initializing Ultimate Particles...</h2>
    <p>Please allow camera access.</p>
  </div>

  <div id="container">
    <video id="input_video" style="display: none;" playsinline webkit-playsinline></video>
    <canvas id="output_canvas"></canvas>
  </div>

<script>
const videoElement = document.getElementById('input_video');
const canvasElement = document.getElementById('output_canvas');
const ctx = canvasElement.getContext('2d');
const loadingOverlay = document.getElementById('loading-overlay');
const statusText = document.getElementById('status-text');

// --- 配置与状态 ---
const MAX_PARTICLES = 1500; // 粒子数量大幅增加
const STATE_WAITING = 0;
const STATE_RUNNING = 1;
let gameState = STATE_WAITING;

function resizeCanvas() {
  canvasElement.width = window.innerWidth;
  canvasElement.height = window.innerHeight;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

let particles = [];
// 存储当前活跃的手的数据
let activeHands = []; 

// --- 炫酷粒子类 ---
class Particle {
  constructor(w, h) {
    this.reset(w, h);
    this.life = Math.random() * 0.5; // 初始随机生命值避免同时产生
  }

  reset(w, h, x, y) {
    this.x = x !== undefined ? x : Math.random() * w;
    this.y = y !== undefined ? y : Math.random() * h;
    this.vx = (Math.random() - 0.5) * 2;
    this.vy = (Math.random() - 0.5) * 2;
    this.life = 1.0;
    // 基础色调 (青蓝色系)
    this.baseHue = 180 + Math.random() * 60; 
    this.hue = this.baseHue;
    this.size = Math.random() * 3 + 1;
    this.lightness = 50;
  }

  update(w, h, hands) {
    // 1. 基础随机扰动 (布朗运动)
    this.vx += (Math.random() - 0.5) * 0.1;
    this.vy += (Math.random() - 0.5) * 0.1;

    // 2. 响应所有活跃的手
    let influenced = false;
    for (const hand of hands) {
      let dx = hand.x - this.x;
      let dy = hand.y - this.y;
      let distSq = dx*dx + dy*dy;
      let dist = Math.sqrt(distSq);

      // 计算力的大小 (距离越近力越大)
      let forceMagnitude = 3000 / (distSq + 100); 
      
      // 根据手掌方向决定吸引(1)还是排斥(-1)
      forceMagnitude *= hand.forceDir; 
      
      this.vx += (dx / dist) * forceMagnitude;
      this.vy += (dy / dist) * forceMagnitude;

      // 如果距离近且是吸引状态，粒子染上手的颜色
      if (dist < 200 && hand.forceDir > 0) {
        // 缓慢向手的颜色过渡
        this.hue = this.hue * 0.9 + hand.hue * 0.1;
        influenced = true;
      }
    }
    
    // 如果没有受到手的强烈影响，缓慢恢复基础色
    if (!influenced) {
         this.hue = this.hue * 0.98 + this.baseHue * 0.02;
    }

    // 3. 物理计算 (阻尼、速度)
    this.vx *= 0.96; // 摩擦力
    this.vy *= 0.96;
    this.x += this.vx;
    this.y += this.vy;
    this.life -= 0.003; // 生命周期衰减

    // 4. 根据速度改变亮度 (越快越亮)
    let speed = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
    this.lightness = Math.min(80, 40 + speed * 5);

    // 5. 边界与重生
    if (this.life <= 0 || this.x < 0 || this.x > w || this.y < 0 || this.y > h) {
      this.reset(w, h);
    }
  }

  draw(ctx) {
    // 使用 HSL 颜色模式实现炫酷光效
    let alpha = this.life * (this.lightness / 80); // 生命值和亮度共同决定透明度
    ctx.fillStyle = `hsla(${this.hue}, 100%, ${this.lightness}%, ${alpha})`;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, 2 * Math.PI);
    ctx.fill();
  }
}

// 初始化粒子池
for (let i = 0; i < MAX_PARTICLES; i++) {
  particles.push(new Particle(canvasElement.width, canvasElement.height));
}

// --- GUI ---
function drawStartGUI() {
  // 半透明黑色背景
  ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
  ctx.fillRect(0, 0, canvasElement.width, canvasElement.height);
  
  ctx.textAlign = 'center';
  ctx.fillStyle = '#FFFFFF';
  ctx.font = 'bold 40px Arial';
  ctx.shadowColor = "#00FFFF"; ctx.shadowBlur = 20; // 文字发光
  ctx.fillText("DUAL-HAND ENERGY", canvasElement.width / 2, canvasElement.height / 2 - 50);
  
  ctx.fillStyle = '#00FFFF';
  ctx.font = '24px Arial';
  ctx.shadowBlur = 10;
  ctx.fillText("Raise Any Hand High to START", canvasElement.width / 2, canvasElement.height / 2 + 30);
  
  // 重置阴影
  ctx.shadowBlur = 0;
}

// --- 核心逻辑 ---
function checkStartGesture(landmarks) {
  return landmarks[0].y < 0.25; // 手腕抬高
}

// 判断手心朝向 (适用于镜像后的画面)
// 如果是右手(Right)，手心朝前时，食指(5)在小指(17)左侧(x更小)
// 如果是左手(Left)，手心朝前时，食指(5)在小指(17)右侧(x更大)
function checkPalmOrientation(landmarks, handedness) {
  const idx_x = landmarks[5].x;
  const pinky_x = landmarks[17].x;
  if (handedness === 'Right') return idx_x < pinky_x;
  else return idx_x > pinky_x;
}

// --- MediaPipe 回调 ---
function onResults(results) {
  if (loadingOverlay.style.display !== 'none') loadingOverlay.style.display = 'none';

  // 【关键特效 1：拖尾效果】
  // 不使用 clearRect，而是覆盖一层半透明黑色，形成残影
  ctx.globalCompositeOperation = 'source-over';
  ctx.fillStyle = 'rgba(0, 0, 0, 0.15)'; 
  ctx.fillRect(0, 0, canvasElement.width, canvasElement.height);

  // 绘制原始视频底图 (可选，为了更炫酷我们可以不画视频，只画粒子和手)
  // ctx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

  const handsData = results.multiHandLandmarks;
  const handednessData = results.multiHandedness;
  
  // 重置每帧的活跃手数据
  activeHands = [];

  // --- 状态机 ---
  if (gameState === STATE_WAITING) {
    drawStartGUI();
    if (handsData.length > 0) {
        // 检查任意一只手是否触发启动
        for (const landmarks of handsData) {
            if (checkStartGesture(landmarks)) {
                gameState = STATE_RUNNING;
                // 爆发特效：所有粒子重置到中心向外扩散
                particles.forEach(p => p.reset(canvasElement.width, canvasElement.height, canvasElement.width/2, canvasElement.height/2));
                break;
            }
        }
    }
  } 
  else if (gameState === STATE_RUNNING) {
    
    // 1. 处理所有检测到的手
    for (let i = 0; i < handsData.length; i++) {
        const landmarks = handsData[i];
        const label = handednessData[i].label; // "Left" or "Right"
        
        // 计算中心点 (手掌中心)
        const hx = (landmarks[0].x + landmarks[9].x) / 2 * canvasElement.width;
        const hy = (landmarks[0].y + landmarks[9].y) / 2 * canvasElement.height;
        
        // 判断朝向
        const isPalm = checkPalmOrientation(landmarks, label);
        const forceDir = isPalm ? 1 : -1;

        // 根据左右手设置不同的主题色 (Left: Blue/Cyan, Right: Orange/Red)
        const handHue = label === 'Left' ? 200 : 30;
        const stateColor = isPalm ? `hsl(${handHue}, 100%, 50%)` : '#FF0000'; // 手背统一红色警告色

        // 记录数据供粒子使用
        activeHands.push({ x: hx, y: hy, forceDir: forceDir, hue: handHue });

        // 绘制手部能量光环
        ctx.globalCompositeOperation = 'lighter'; // 发光叠加模式
        
        // 外圈光晕
        let gradient = ctx.createRadialGradient(hx, hy, 10, hx, hy, 60);
        gradient.addColorStop(0, stateColor);
        gradient.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = gradient;
        ctx.beginPath(); ctx.arc(hx, hy, 60, 0, Math.PI*2); ctx.fill();

        // 核心光点
        ctx.fillStyle = stateColor;
        ctx.beginPath(); ctx.arc(hx, hy, 15, 0, Math.PI*2); ctx.fill();

        // 绘制骨架
        drawConnectors(ctx, landmarks, HAND_CONNECTIONS, {color: stateColor, lineWidth: 2});
        drawLandmarks(ctx, landmarks, {color: '#FFFFFF', lineWidth: 1, radius: 3});
    }

    // 【关键特效 2：发光粒子叠加】
    ctx.globalCompositeOperation = 'lighter'; 

    // 2. 更新并绘制所有粒子
    for (const p of particles) {
        p.update(canvasElement.width, canvasElement.height, activeHands);
        p.draw(ctx);
    }
  }
  // 恢复默认混合模式
  ctx.globalCompositeOperation = 'source-over';
}

// --- 初始化 MediaPipe ---
const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
hands.setOptions({
  maxNumHands: 2, // 【关键修改】开启双手支持
  modelComplexity: 1, // 使用中等模型以平衡双手性能和精度
  minDetectionConfidence: 0.6,
  minTrackingConfidence: 0.6
});
hands.onResults(onResults);

const camera = new Camera(videoElement, {
  onFrame: async () => await hands.send({image: videoElement}),
  width: 1280, height: 720 // 使用较高分辨率以获得更好的双手识别
});

statusText.innerHTML = "Downloading AI Model...<br>Prepare for HIGH PERFORMANCE usage.";
camera.start().catch(err => { statusText.innerHTML = "Error: " + err.message; statusText.style.color = "red"; });

</script>
</body>
</html>
