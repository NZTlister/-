<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Magic Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        
        /* è°ƒè¯•æ—¥å¿— */
        #debug-console {
            position: absolute; top: 0; left: 0; width: 100%; padding: 10px;
            color: lime; font-size: 12px; pointer-events: none; z-index: 999;
            text-shadow: 1px 1px 2px black;
        }

        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        /* æ‘„åƒå¤´å°çª— (æ”¾åœ¨å³ä¸‹è§’) */
        #video-input { 
            position: absolute; bottom: 10px; right: 10px; width: 120px; 
            transform: scaleX(-1); z-index: 10; border: 1px solid #333; border-radius: 8px;
            display: none; 
        }
        
        /* å¯åŠ¨æŒ‰é’® */
        #start-btn {
            position: absolute; bottom: 15%; left: 50%; transform: translateX(-50%);
            padding: 12px 40px; font-size: 16px; border-radius: 30px;
            background: #00d2ff; color: #000; border: none; font-weight: bold;
            cursor: pointer; z-index: 100; box-shadow: 0 0 15px #00d2ff;
        }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.esm.min.js"
            }
        }
    </script>
</head>
<body>
    <div id="debug-console">ç­‰å¾… JS åŠ è½½...</div>
    <div id="canvas-container"></div>
    <video id="video-input" playsinline></video>
    <button id="start-btn" style="display:none">ğŸ“· å¼€å¯æ‰‹åŠ¿æ§åˆ¶</button>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import GUI from 'lil-gui';

        const logDiv = document.getElementById('debug-console');
        function log(msg) { logDiv.innerText = `> ${msg}`; console.log(msg); }
        window.onerror = (e) => log("âŒ " + e);

        // å…¨å±€å˜é‡
        let scene, camera, renderer, particles, geometry, material, cube;
        let positionsOriginal = [], handScaleFactor = 1.0;
        const PARTICLE_COUNT = 5000;

        // --- 1. ç«‹å³åˆå§‹åŒ– 3D åœºæ™¯ (ä¸ç­‰å¾…æ‘„åƒå¤´) ---
        initThree();
        animate(); // ç«‹å³å¼€å§‹æ¸²æŸ“å¾ªç¯
        log("âœ… 3D å¼•æ“å·²å¯åŠ¨ (ä½ åº”è¯¥èƒ½çœ‹åˆ°æ—‹è½¬çš„ç²’å­)");

        // --- 2. èµ„æºæ£€æµ‹ (ç”¨äºå¼€å¯æ‘„åƒå¤´) ---
        const checkTimer = setInterval(() => {
            if (window.Hands && window.Camera) {
                clearInterval(checkTimer);
                document.getElementById('start-btn').style.display = 'block';
                log("MediaPipe å°±ç»ªï¼Œç‚¹å‡»æŒ‰é’®å¼€å¯äº’åŠ¨");
            }
        }, 500);

        // --- 3. æŒ‰é’®äº‹ä»¶ ---
        document.getElementById('start-btn').addEventListener('click', async function() {
            this.style.display = 'none';
            log("æ­£åœ¨è¯·æ±‚æ‘„åƒå¤´...");
            try {
                const hands = new window.Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
                hands.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
                hands.onResults((res) => {
                    if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
                        const lm = res.multiHandLandmarks[0];
                        const d = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                        // ç¼©æ”¾æ˜ å°„
                        const target = 0.5 + Math.min(Math.max((d-0.02)/0.2,0),1) * 2.0;
                        handScaleFactor += (target - handScaleFactor) * 0.1;
                    } else {
                        handScaleFactor += (1.0 - handScaleFactor) * 0.05;
                    }
                });

                const video = document.getElementById('video-input');
                const cameraUtils = new window.Camera(video, {
                    onFrame: async () => { await hands.send({image: video}); },
                    width: 640, height: 480, facingMode: "user"
                });
                await cameraUtils.start();
                video.style.display = 'block';
                log("âœ… æ‘„åƒå¤´å·²è¿æ¥ï¼Œæåˆæ‰‹æŒ‡è¯•è¯•ï¼");
                
                // æ‘„åƒå¤´æˆåŠŸåï¼Œéšè—çº¢è‰²è°ƒè¯•æ–¹å—
                if(cube) cube.visible = false;

            } catch(e) {
                alert("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥: " + e.message);
                log("âŒ " + e.message);
                this.style.display = 'block';
            }
        });

        // --- Three.js æ ¸å¿ƒé€»è¾‘ ---
        function initThree() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.02);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.z = 20;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            // æ§åˆ¶å™¨
            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 1.0;

            // [è°ƒè¯•] æ·»åŠ ä¸€ä¸ªçº¢è‰²çš„ç«‹æ–¹ä½“åœ¨ä¸­å¿ƒ
            // å¦‚æœä½ èƒ½çœ‹åˆ°è¿™ä¸ªæ–¹å—ï¼Œè¯´æ˜ WebGL æ˜¯æ­£å¸¸çš„
            const boxGeo = new THREE.BoxGeometry(2, 2, 2);
            const boxMat = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });
            cube = new THREE.Mesh(boxGeo, boxMat);
            scene.add(cube);

            // ç²’å­ç³»ç»Ÿ
            geometry = new THREE.BufferGeometry();
            const pos = new Float32Array(PARTICLE_COUNT * 3);
            geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));

            // åˆ›å»ºç®€å•çš„å‘å…‰çº¹ç†
            const cvs = document.createElement('canvas'); 
            cvs.width = 64; cvs.height = 64; // å¢å¤§çº¹ç†
            const ctx = cvs.getContext('2d');
            ctx.beginPath();
            ctx.arc(32, 32, 30, 0, Math.PI * 2);
            ctx.fillStyle = '#ffffff';
            ctx.fill();
            const tex = new THREE.Texture(cvs); tex.needsUpdate = true;

            material = new THREE.PointsMaterial({
                size: 0.4, // å¢å¤§ç²’å­å°ºå¯¸
                map: tex,
                color: 0x00d2ff,
                transparent: true, 
                opacity: 0.9,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // é»˜è®¤å½¢çŠ¶
            updateShape('Galaxy');

            // GUI
            const gui = new GUI();
            gui.domElement.style.top = '10px';
            const params = { shape: 'Galaxy', color: '#00d2ff' };
            
            gui.add(params, 'shape', ['Galaxy', 'Heart', 'Nebula', 'Spiral', 'Sphere', 'DNA']).onChange(v => updateShape(v));
            gui.addColor(params, 'color').onChange(v => material.color.set(v));

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth/window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // --- å½¢çŠ¶å…¬å¼ ---
        function updateShape(type) {
            const count = PARTICLE_COUNT;
            const arr = new Float32Array(count * 3);
            for(let i=0; i<count; i++) {
                const i3 = i*3;
                let x=0, y=0, z=0;
                
                if (type === 'Galaxy') {
                    const arms = 3; 
                    const spin = i * 0.002;
                    const branch = i % arms;
                    const r = Math.random() * 15;
                    const a = spin + (Math.PI*2/arms)*branch;
                    x = Math.cos(a)*r + (Math.random()-0.5);
                    y = (Math.random()-0.5)*2;
                    z = Math.sin(a)*r + (Math.random()-0.5);
                } 
                else if (type === 'Heart') {
                    const t = (i/count)*Math.PI*2;
                    const phi = Math.acos(-1+(2*i)/count);
                    const theta = Math.sqrt(count*Math.PI)*phi;
                    x = 16*Math.pow(Math.sin(theta),3) * 0.4;
                    y = (13*Math.cos(theta)-5*Math.cos(2*theta)-2*Math.cos(3*theta)-Math.cos(4*theta)) * 0.4;
                    z = 8*Math.cos(phi) * 0.4;
                }
                else if (type === 'Nebula') {
                    const r = 8 * Math.cbrt(Math.random()); 
                    const theta = Math.random() * 2 * Math.PI;
                    const phi = Math.acos(2 * Math.random() - 1);
                    x = r * Math.sin(phi) * Math.cos(theta) * (1 + Math.sin(theta*5)*0.2);
                    y = r * Math.sin(phi) * Math.sin(theta) * (1 + Math.cos(phi*5)*0.2);
                    z = r * Math.cos(phi);
                }
                else if (type === 'Spiral') {
                    const r = i * 0.003; 
                    const a = i * 0.1;
                    x = r * Math.cos(a);
                    y = (Math.random()-0.5)*5;
                    z = r * Math.sin(a);
                }
                else if (type === 'DNA') {
                    const t = i * 0.1;
                    const r = 3;
                    x = Math.cos(t) * r;
                    y = (i/count) * 20 - 10;
                    z = Math.sin(t) * r;
                    // åŒèºæ—‹
                    if (i % 2 === 0) { x = -x; z = -z; }
                }
                else { // Sphere
                    const r = 8;
                    const phi = Math.acos( -1 + ( 2 * i ) / count );
                    const theta = Math.sqrt( count * Math.PI ) * phi;
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                }

                arr[i3] = x; arr[i3+1] = y; arr[i3+2] = z;
            }
            positionsOriginal = arr;
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const pos = particles.geometry.attributes.position.array;
            
            // ç²’å­æ’å€¼åŠ¨ç”»
            for(let i=0; i<pos.length; i++) {
                // å¦‚æœ positionsOriginal è¿˜æ²¡å‡†å¤‡å¥½ï¼ˆè™½ç„¶åˆå§‹åŒ–å°±å‡†å¤‡å¥½äº†ï¼‰ï¼Œå°±ä¿æŒåŸæ ·
                if (positionsOriginal.length > 0) {
                    pos[i] += (positionsOriginal[i] * handScaleFactor - pos[i]) * 0.08;
                }
            }
            
            particles.geometry.attributes.position.needsUpdate = true;
            
            // è®©çº¢è‰²æ–¹å—ä¹Ÿè½¬èµ·æ¥
            if(cube) {
                cube.rotation.x += 0.01;
                cube.rotation.y += 0.01;
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
