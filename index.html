<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Advanced Particle System</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        
        /* è°ƒè¯•/çŠ¶æ€ä¿¡æ¯ */
        #status-bar {
            position: absolute; top: 0; left: 0; width: 100%; padding: 8px;
            color: rgba(255,255,255,0.7); font-size: 12px; pointer-events: none; z-index: 999;
            text-align: center; background: linear-gradient(to bottom, rgba(0,0,0,0.5), transparent);
        }

        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* æ‘„åƒå¤´å°çª— */
        #video-input { 
            position: absolute; bottom: 10px; right: 10px; width: 100px; 
            transform: scaleX(-1); z-index: 10; border: 1px solid rgba(255,255,255,0.3); border-radius: 8px;
            display: none; opacity: 0.6; transition: opacity 0.3s;
        }
        #video-input:hover { opacity: 1.0; }
        
        /* å¯åŠ¨æŒ‰é’® */
        #start-btn {
            position: absolute; bottom: 20%; left: 50%; transform: translateX(-50%);
            padding: 14px 40px; font-size: 16px; border-radius: 30px;
            background: linear-gradient(45deg, #00d2ff, #3a7bd5);
            color: white; border: none; font-weight: bold; letter-spacing: 1px;
            cursor: pointer; z-index: 100; box-shadow: 0 5px 20px rgba(0, 210, 255, 0.4);
            transition: transform 0.2s, box-shadow 0.2s;
            display: none; /* JSæ§åˆ¶æ˜¾ç¤º */
        }
        #start-btn:active { transform: translateX(-50%) scale(0.95); box-shadow: 0 2px 10px rgba(0, 210, 255, 0.3); }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.esm.min.js"
            }
        }
    </script>
</head>
<body>
    <div id="status-bar">âš¡ æ­£åœ¨åˆå§‹åŒ–é«˜ç²¾åº¦ç²’å­å¼•æ“...</div>
    <div id="canvas-container"></div>
    <video id="video-input" playsinline></video>
    <button id="start-btn">âœ¨ å¯åŠ¨æ‰‹åŠ¿æ§åˆ¶</button>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import GUI from 'lil-gui';

        const statusDiv = document.getElementById('status-bar');
        function setStatus(msg) { statusDiv.innerHTML = msg; }
        window.onerror = (e) => setStatus("âŒ é”™è¯¯: " + e);

        // --- å…¨å±€é…ç½® ---
        // æå‡ç²’å­æ•°é‡åˆ° 12000 ä»¥è·å¾—æ›´ç²¾ç»†çš„æ•ˆæœ
        const PARTICLE_COUNT = 12000; 
        // æ‰‹åŠ¿çµæ•åº¦å‚æ•° (èŒƒå›´è¶Šå¤§è¶Šçµæ•)
        const SENSITIVITY_MIN = 0.1; // æåˆåˆ°æœ€ç´§æ—¶çš„ç¼©æ”¾ (æ±‡èš)
        const SENSITIVITY_MAX = 4.0; // å¼ å¼€åˆ°æœ€å¤§æ—¶çš„ç¼©æ”¾ (çˆ†ç‚¸)
        // åŠ¨ç”»è·Ÿéšé€Ÿåº¦ (è¶Šå¤§è¶Šè·Ÿæ‰‹)
        const LERP_SPEED = 0.12; 

        let scene, camera, renderer, particles, geometry, material, controls;
        let positionsOriginal = [], handScaleFactor = 1.0, isRunning = false;
        const config = { shape: 'Galaxy', color: '#00d2ff', autoRotate: true };

        // --- 1. ç«‹å³åˆå§‹åŒ– 3D åœºæ™¯ ---
        initThree();
        animate(); 
        setStatus("âœ… 3D å¼•æ“å°±ç»ªã€‚æ­£åœ¨åŠ è½½ AI æ¨¡å‹...");

        // --- 2. èµ„æºæ£€æµ‹ ---
        const checkTimer = setInterval(() => {
            if (window.Hands && window.Camera) {
                clearInterval(checkTimer);
                document.getElementById('start-btn').style.display = 'block';
                setStatus("ç­‰å¾…ç”¨æˆ·å¯åŠ¨...");
            }
        }, 500);

        // --- 3. å¯åŠ¨æŒ‰é’®äº‹ä»¶ ---
        document.getElementById('start-btn').addEventListener('click', async function() {
            this.style.display = 'none';
            setStatus("æ­£åœ¨è¯·æ±‚æ‘„åƒå¤´æƒé™ï¼Œè¯·å…è®¸...");
            try {
                const hands = new window.Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
                hands.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
                
                // é«˜çµæ•åº¦æ‰‹åŠ¿å¤„ç†é€»è¾‘
                hands.onResults((res) => {
                    if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
                        const lm = res.multiHandLandmarks[0];
                        // è®¡ç®—æ‹‡æŒ‡(4)å’Œé£ŸæŒ‡(8)çš„è·ç¦»
                        const d = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                        
                        // æ ¸å¿ƒæ”¹è¿›ï¼šæ›´å¹¿çš„æ˜ å°„èŒƒå›´å’Œæ›´é«˜çš„çµæ•åº¦
                        // å°†è·ç¦» d (å¤§çº¦ 0.02~0.25) æ˜ å°„åˆ° [SENSITIVITY_MIN, SENSITIVITY_MAX]
                        let normalized = (d - 0.02) / (0.25 - 0.02);
                        normalized = Math.max(0, Math.min(1, normalized)); // é’³åˆ¶åœ¨ 0-1 ä¹‹é—´
                        
                        // ä½¿ç”¨éçº¿æ€§æ˜ å°„ (å¹³æ–¹) è®©å¼ å¼€æ—¶çš„çˆ†å‘æ„Ÿæ›´å¼º
                        // normalized = normalized * normalized; 

                        const targetScale = SENSITIVITY_MIN + normalized * (SENSITIVITY_MAX - SENSITIVITY_MIN);
                        
                        // å¹³æ»‘è¿‡æ¸¡åˆ°ç›®æ ‡ç¼©æ”¾å€¼
                        handScaleFactor += (targetScale - handScaleFactor) * LERP_SPEED;
                    } else {
                        // æ²¡æœ‰æ£€æµ‹åˆ°æ‰‹æ—¶ï¼Œç¼“æ…¢æ¢å¤åˆ°é»˜è®¤å¤§å° (1.0)
                        handScaleFactor += (1.0 - handScaleFactor) * 0.05;
                    }
                });

                const video = document.getElementById('video-input');
                const cameraUtils = new window.Camera(video, {
                    onFrame: async () => { await hands.send({image: video}); },
                    width: 640, height: 480, facingMode: "user"
                });
                await cameraUtils.start();
                video.style.display = 'block';
                isRunning = true;
                setStatus("ğŸ–ï¸ æ‰‹åŠ¿æ§åˆ¶å·²æ¿€æ´»ï¼æåˆæ‰‹æŒ‡æ±‡èšï¼Œå¼ å¼€æ‰‹æŒ‡çˆ†ç‚¸ã€‚å•æŒ‡æ‹–åŠ¨å¯ç¿»è½¬è§†è§’ã€‚");
                // å¯åŠ¨åè‡ªåŠ¨å…³é—­è‡ªåŠ¨æ—‹è½¬ï¼Œæ–¹ä¾¿ç”¨æˆ·æ‰‹åŠ¨æ“ä½œ
                config.autoRotate = false; 
                gui.controllers.find(c => c.property === 'autoRotate').updateDisplay();

            } catch(e) {
                alert("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥: " + e.message);
                setStatus("âŒ " + e.message);
                this.style.display = 'block';
            }
        });

        // --- Three.js æ ¸å¿ƒé€»è¾‘ ---
        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            // æ›´æ·±é‚ƒçš„é›¾æ•ˆ
            scene.fog = new THREE.FogExp2(0x000000, 0.01);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.z = 25; // ç›¸æœºç¨è¿œï¼Œä»¥å®¹çº³çˆ†ç‚¸æ•ˆæœ

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // é™åˆ¶åƒç´ æ¯”ä»¥ä¼˜åŒ–æ€§èƒ½
            container.appendChild(renderer.domElement);

            // æ§åˆ¶å™¨ (å…è®¸ç”¨æˆ·ç¿»è½¬/æŸ¥çœ‹)
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = config.autoRotate;
            controls.autoRotateSpeed = 0.5;

            // ç²’å­ç³»ç»Ÿåˆå§‹åŒ–
            geometry = new THREE.BufferGeometry();
            const pos = new Float32Array(PARTICLE_COUNT * 3);
            geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));

            // åˆ›å»ºæ›´ç²¾ç»†çš„å‘å…‰çº¹ç† (ä¸­å¿ƒäº®ï¼Œè¾¹ç¼˜æŸ”å’Œ)
            const cvs = document.createElement('canvas'); cvs.width = 64; cvs.height = 64;
            const ctx = cvs.getContext('2d');
            const grd = ctx.createRadialGradient(32,32,0,32,32,32);
            grd.addColorStop(0,'rgba(255,255,255,1)'); // ä¸­å¿ƒçº¯ç™½
            grd.addColorStop(0.3,'rgba(255,255,255,0.8)'); 
            grd.addColorStop(0.5,'rgba(255,255,255,0.2)'); 
            grd.addColorStop(1,'rgba(0,0,0,0)'); // è¾¹ç¼˜é€æ˜
            ctx.fillStyle = grd; ctx.fillRect(0,0,64,64);
            const tex = new THREE.Texture(cvs); tex.needsUpdate = true;

            material = new THREE.PointsMaterial({
                size: 0.15, // ã€ç²¾ç»†åŒ–ã€‘æ˜¾è‘—ç¼©å°ç²’å­å°ºå¯¸
                map: tex,
                color: config.color,
                transparent: true, 
                opacity: 0.9, // æé«˜ä¸é€æ˜åº¦å¢åŠ äº®åº¦
                blending: THREE.AdditiveBlending, // å‘å…‰å åŠ æ¨¡å¼
                depthWrite: false // å…³é—­æ·±åº¦å†™å…¥ä»¥å®ç°é€æ˜å åŠ 
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // åˆå§‹å½¢çŠ¶
            updateShape(config.shape);

            // GUI é¢æ¿
            setupGUI();

            window.addEventListener('resize', onWindowResize);
        }

        function setupGUI() {
            const gui = new GUI({ title: 'æ§åˆ¶é¢æ¿' });
            gui.domElement.style.top = '10px';
            gui.domElement.style.right = '10px';
            
            // æ·»åŠ æ–°çš„å½¢çŠ¶
            const shapes = ['Galaxy', 'Heart', 'Explode', 'Cube', 'Ring', 'Wave', 'Sphere'];
            gui.add(config, 'shape', shapes).name('åˆ‡æ¢å½¢çŠ¶').onChange(v => updateShape(v));
            gui.addColor(config, 'color').name('ç²’å­é¢œè‰²').onChange(v => material.color.set(v));
            gui.add(config, 'autoRotate').name('è‡ªåŠ¨æ—‹è½¬').onChange(v => controls.autoRotate = v);
        }

        // --- æ ¸å¿ƒï¼šæ›´ä¸°å¯Œçš„å½¢çŠ¶ç”Ÿæˆå…¬å¼ ---
        function updateShape(type) {
            const count = PARTICLE_COUNT;
            const arr = new Float32Array(count * 3);
            for(let i=0; i<count; i++) {
                const i3 = i*3;
                let x=0, y=0, z=0;
                const random = Math.random();
                
                switch(type) {
                    case 'Galaxy': // ç»å…¸é“¶æ²³
                        const arms = 5; 
                        const spin = i * 0.001;
                        const branch = i % arms;
                        const rG = random * 15;
                        const aG = spin + (Math.PI*2/arms)*branch;
                        x = Math.cos(aG)*rG + (Math.random()-0.5);
                        y = (Math.random()-0.5) * (rG*0.1 + 0.5);
                        z = Math.sin(aG)*rG + (Math.random()-0.5);
                        break;

                    case 'Heart': // 3Dçˆ±å¿ƒ
                        const phiH = Math.acos(-1+(2*i)/count);
                        const thetaH = Math.sqrt(count*Math.PI)*phiH;
                        x = 16*Math.pow(Math.sin(thetaH),3) * 0.5;
                        y = (13*Math.cos(thetaH)-5*Math.cos(2*thetaH)-2*Math.cos(3*thetaH)-Math.cos(4*thetaH)) * 0.5;
                        z = 8*Math.cos(phiH) * 0.5;
                        break;

                    case 'Explode': // ã€æ–°å¢ã€‘å¤§çˆ†ç‚¸/éšæœºæ•£å¸ƒ
                        // åœ¨ä¸€ä¸ªå¤§çƒä½“å†…éšæœºåˆ†å¸ƒ
                        const rE = random * 35; // è¶…å¤§åŠå¾„
                        const thetaE = random * Math.PI * 2;
                        const phiE = Math.acos(2 * random - 1);
                        x = rE * Math.sin(phiE) * Math.cos(thetaE);
                        y = rE * Math.sin(phiE) * Math.sin(thetaE);
                        z = rE * Math.cos(phiE);
                        break;

                    case 'Cube': // ã€æ–°å¢ã€‘ç«‹æ–¹ä½“çŸ©é˜µ
                        // ç®€å•çš„è®¡ç®—æ–¹æ³•ï¼šå°†ç´¢å¼•æ˜ å°„åˆ° 3D ç½‘æ ¼
                        const side = Math.ceil(Math.cbrt(count));
                        const spacing = 1.5;
                        const offset = (side * spacing) / 2;
                        const ix = i % side;
                        const iy = Math.floor(i / side) % side;
                        const iz = Math.floor(i / (side * side));
                        x = ix * spacing - offset + (random-0.5)*0.5;
                        y = iy * spacing - offset + (random-0.5)*0.5;
                        z = iz * spacing - offset + (random-0.5)*0.5;
                        break;

                    case 'Ring': // ã€æ–°å¢ã€‘æ˜Ÿç¯
                        const rR = 10 + random * 4; // å†…å¾„10ï¼Œå¤–å¾„14
                        const aR = i * 0.01;
                        x = rR * Math.cos(aR);
                        y = (random - 0.5) * 0.5; // éå¸¸æ‰å¹³
                        z = rR * Math.sin(aR);
                        break;

                    case 'Wave': // ã€æ–°å¢ã€‘æ³¢åŠ¨å¹³é¢
                        const width = 40;
                        const depth = 40;
                        const cols = Math.sqrt(count);
                        const rows = Math.sqrt(count);
                        const row = Math.floor(i / cols);
                        const col = i % cols;
                        x = (col / cols) * width - width/2;
                        z = (row / rows) * depth - depth/2;
                        // ä½¿ç”¨æ­£å¼¦æ³¢ç”Ÿæˆé«˜åº¦ y
                        y = Math.sin(x * 0.2) * 2 + Math.cos(z * 0.2) * 2;
                        break;

                    default: // Sphere (æ±‡èšæ€/çƒä½“)
                        const rS = 8;
                        const phiS = Math.acos( -1 + ( 2 * i ) / count );
                        const thetaS = Math.sqrt( count * Math.PI ) * phiS;
                        x = rS * Math.sin(phiS) * Math.cos(thetaS);
                        y = rS * Math.sin(phiS) * Math.sin(thetaS);
                        z = rS * Math.cos(phiS);
                        break;
                }
                arr[i3] = x; arr[i3+1] = y; arr[i3+2] = z;
            }
            positionsOriginal = arr;
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const pos = particles.geometry.attributes.position.array;
            // æ ¸å¿ƒåŠ¨ç”»å¾ªç¯ï¼šå¿«é€Ÿæ’å€¼åˆ° (ç›®æ ‡ä½ç½® * æ‰‹åŠ¿ç¼©æ”¾)
            for(let i=0; i<pos.length; i++) {
                if (positionsOriginal.length > 0) {
                    // LERP_SPEED è¶Šå¤§ï¼Œååº”è¶Šå¿«
                    pos[i] += (positionsOriginal[i] * handScaleFactor - pos[i]) * LERP_SPEED;
                }
            }
            particles.geometry.attributes.position.needsUpdate = true;
            
            controls.update(); // æ›´æ–°æ§åˆ¶å™¨ (å¤„ç†è‡ªåŠ¨æ—‹è½¬å’Œé˜»å°¼)
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
