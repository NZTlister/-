<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D 手势粒子 (GitHub Pages 版)</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #canvas-container { position: absolute; width: 100%; height: 100%; z-index: 1; }
        #video-input { position: absolute; bottom: 10px; right: 10px; width: 120px; z-index: 10; transform: scaleX(-1); display: none; border: 1px solid #fff; }
        
        /* 加载层 */
        #overlay { position: absolute; top:0; left:0; width:100%; height:100%; background:#000; z-index:100; display:flex; flex-direction:column; align-items:center; justify-content:center; color:white; }
        .spinner { width: 40px; height: 40px; border: 4px solid #333; border-top: 4px solid #00d2ff; border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px;}
        #status { color: #ccc; font-size: 14px; text-align: center; max-width: 80%; }
        
        /* 启动按钮 */
        #start-btn { margin-top: 20px; padding: 10px 30px; border: 1px solid #00d2ff; color: #00d2ff; background: rgba(0,210,255,0.1); border-radius: 20px; display: none; cursor: pointer; }
        
        /* 屏幕日志 (用于手机调试) */
        #console-log { position: absolute; bottom: 0; left: 0; width: 100%; height: 150px; background: rgba(0,0,0,0.5); color: #0f0; font-size: 10px; overflow-y: scroll; z-index: 200; pointer-events: none; display: none;}
        
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>

    <script>
        window.onerror = function(msg, source, lineno) {
            const log = document.getElementById('console-log');
            if(log) {
                log.style.display = 'block';
                log.innerHTML += `<div style="color:red">ERROR: ${msg}</div>`;
            }
        };
        function logMsg(msg) {
            const log = document.getElementById('console-log');
            if(log) log.innerHTML += `<div>> ${msg}</div>`;
        }
    </script>

    <script src="https://unpkg.zhimg.com/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.zhimg.com/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.zhimg.com/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.zhimg.com/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://registry.npmmirror.com/three/0.160.0/files/build/three.module.js",
                "three/addons/": "https://registry.npmmirror.com/three/0.160.0/files/examples/jsm/",
                "lil-gui": "https://registry.npmmirror.com/lil-gui/0.19.1/files/dist/lil-gui.esm.min.js"
            }
        }
    </script>
</head>
<body>
    <div id="console-log"></div>
    <video id="video-input" playsinline></video>
    <div id="canvas-container"></div>
    
    <div id="overlay">
        <div class="spinner" id="spinner"></div>
        <div id="status">正在加载资源...<br>如果卡住，请检查网络</div>
        <button id="start-btn">启动体验 (Start)</button>
        <button id="force-btn" style="display:none; margin-top:10px; color:#aaa; background:none; border:none; border-bottom:1px solid #555;">等待太久? 强制进入</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import GUI from 'lil-gui';

        logMsg("Three.js 模块已加载");

        const els = {
            overlay: document.getElementById('overlay'),
            status: document.getElementById('status'),
            startBtn: document.getElementById('start-btn'),
            spinner: document.getElementById('spinner'),
            video: document.getElementById('video-input'),
            forceBtn: document.getElementById('force-btn')
        };

        let scene, camera, renderer, particles, geometry, material;
        let positionsOriginal = [], handScaleFactor = 1.0;
        let isRunning = false;
        
        // --- 资源检查 ---
        let loaded = false;
        const checkTimer = setInterval(() => {
            if (window.Hands && window.Camera && THREE) {
                clearInterval(checkTimer);
                loaded = true;
                els.spinner.style.display = 'none';
                els.status.innerText = "资源加载完毕 ✅";
                els.startBtn.style.display = 'block';
                els.forceBtn.style.display = 'none';
                logMsg("所有库检测通过");
            }
        }, 500);

        // --- 超时处理 ---
        setTimeout(() => {
            if (!loaded) {
                els.status.innerText = "加载似乎卡住了 (可能是网络原因)";
                els.forceBtn.style.display = 'block';
                document.getElementById('console-log').style.display = 'block'; // 显示日志供排查
                logMsg("超时：请检查上方是否有红色报错");
            }
        }, 8000); // 8秒后显示强制按钮

        els.forceBtn.addEventListener('click', () => {
            els.spinner.style.display = 'none';
            els.startBtn.style.display = 'block';
            els.forceBtn.style.display = 'none';
        });

        // --- 启动逻辑 ---
        els.startBtn.addEventListener('click', async () => {
            els.startBtn.style.display = 'none';
            els.spinner.style.display = 'block';
            els.status.innerText = "正在请求摄像头...";

            try {
                // MediaPipe 配置
                const hands = new window.Hands({locateFile: (file) => {
                    // 强制使用知乎镜像加载模型文件
                    return `https://unpkg.zhimg.com/@mediapipe/hands/${file}`;
                }});
                
                hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
                hands.onResults(onHandResults);

                // 摄像头
                const cameraUtils = new window.Camera(els.video, {
                    onFrame: async () => { await hands.send({image: els.video}); },
                    width: 640, height: 480, facingMode: "user"
                });
                
                logMsg("正在启动摄像头...");
                await cameraUtils.start();
                logMsg("摄像头启动成功");

                // 3D 场景
                initThree();
                animate();

                els.video.style.display = 'block';
                els.overlay.style.opacity = 0;
                setTimeout(() => els.overlay.style.display = 'none', 500);
                isRunning = true;

            } catch (e) {
                console.error(e);
                logMsg("Error: " + e.message);
                els.status.innerText = "启动失败: " + e.message;
                els.status.style.color = "red";
                alert("无法启动: " + e.message);
            }
        });

        // --- Three.js 逻辑 ---
        function initThree() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.02);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.z = 20;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            new OrbitControls(camera, renderer.domElement).enableDamping = true;

            // 粒子
            updateShape('Galaxy');
            
            // 生成纹理
            const cvs = document.createElement('canvas'); cvs.width=32; cvs.height=32;
            const ctx = cvs.getContext('2d');
            const grd = ctx.createRadialGradient(16,16,0,16,16,16);
            grd.addColorStop(0,'rgba(255,255,255,1)'); grd.addColorStop(1,'rgba(0,0,0,0)');
            ctx.fillStyle = grd; ctx.fillRect(0,0,32,32);
            const tex = new THREE.Texture(cvs); tex.needsUpdate = true;

            material = new THREE.PointsMaterial({
                color: '#00d2ff', size: 0.1, map: tex,
                transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending, depthWrite: false
            });
            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // GUI
            const gui = new GUI({ title: 'Control' });
            gui.domElement.style.marginTop = '20px';
            gui.addColor({c:'#00d2ff'}, 'c').onChange(v => material.color.set(v)).name('Color');
            gui.add({s:'Galaxy'}, 's', ['Galaxy', 'Heart', 'Sphere']).onChange(v => updateShape(v)).name('Shape');

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth/window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function updateShape(type) {
            const count = 8000;
            const pos = new Float32Array(count * 3);
            for(let i=0; i<count; i++) {
                let x,y,z;
                if(type==='Galaxy') {
                    const a=i*0.1, r=2+i*0.005; x=Math.cos(a)*r; y=(Math.random()-0.5)*2; z=Math.sin(a)*r;
                } else if(type==='Heart') {
                    const t=(i/count)*Math.PI*2, p=Math.acos(-1+(2*i)/count), th=Math.sqrt(count*Math.PI)*p;
                    x=16*Math.pow(Math.sin(th),3)*0.5; y=(13*Math.cos(th)-5*Math.cos(2*th)-2*Math.cos(3*th)-Math.cos(4*th))*0.5; z=10*Math.cos(p)*0.5;
                } else {
                    const r=6, p=Math.acos(-1+(2*i)/count), th=Math.sqrt(count*Math.PI)*p;
                    x=r*Math.sin(p)*Math.cos(th); y=r*Math.sin(p)*Math.sin(th); z=r*Math.cos(p);
                }
                pos[i*3]=x+(Math.random()-0.5); pos[i*3+1]=y+(Math.random()-0.5); pos[i*3+2]=z+(Math.random()-0.5);
            }
            positionsOriginal = pos;
            if(!geometry) {
                geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            } else {
                // 如果已经初始化，平滑过渡的逻辑稍微复杂，这里简化处理直接重置
                // 实际动画在 animate 里
            }
        }

        function animate() {
            if(!isRunning) return;
            requestAnimationFrame(animate);
            const pos = particles.geometry.attributes.position.array;
            for(let i=0; i<positionsOriginal.length; i++) {
                pos[i] += (positionsOriginal[i]*handScaleFactor - pos[i]) * 0.08;
            }
            particles.geometry.attributes.position.needsUpdate = true;
            particles.rotation.y += 0.002;
            renderer.render(scene, camera);
        }

        function onHandResults(res) {
            if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
                const lm = res.multiHandLandmarks[0];
                const d = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                const target = 0.5 + Math.min(Math.max((d-0.02)/0.18,0),1)*2.0;
                handScaleFactor += (target - handScaleFactor) * 0.1;
            } else {
                handScaleFactor += (1.0 - handScaleFactor) * 0.05;
            }
        }
    </script>
</body>
</html>

