<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Romantic Particle System Pro</title>
    <style>
        :root {
            --glass-bg: rgba(255, 255, 255, 0.1);
            --glass-border: rgba(255, 255, 255, 0.25);
            --primary-color: #ff69b4;
        }
        body { margin: 0; overflow: hidden; background: #080810; font-family: 'Segoe UI', Roboto, sans-serif; }
        
        /* 3D å®¹å™¨ */
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; background: radial-gradient(circle at center, #1a1a2e 0%, #000000 100%); }

        /* UI é€šç”¨æ¯›ç»ç’ƒé£æ ¼ */
        .glass-panel {
            background: var(--glass-bg);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }

        /* æ‘„åƒå¤´çª—å£ */
        #camera-container {
            position: absolute;
            top: 20px;
            right: 80px; /* ç•™å‡ºå…¨å±æŒ‰é’®ä½ç½® */
            width: 160px;
            height: 120px;
            z-index: 10;
            border-radius: 16px;
            overflow: hidden;
            opacity: 0; /* åˆå§‹éšè—ï¼Œå¯åŠ¨åæ˜¾ç¤º */
            transform: translateY(-20px);
            transition: opacity 0.5s, transform 0.5s;
        }
        #camera-container.active { opacity: 1; transform: translateY(0); }
        #video-input { 
            width: 100%; height: 100%; object-fit: cover; 
            transform: scaleX(-1); /* é•œåƒæ˜¾ç¤º */
        }

        /* åº•éƒ¨æ§åˆ¶é¢æ¿ */
        #ui-panel {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            padding: 12px 20px;
            border-radius: 40px;
            display: flex;
            gap: 12px;
            align-items: center;
        }
        
        .btn {
            background: rgba(255,255,255,0.05);
            border: 1px solid var(--glass-border);
            color: rgba(255,255,255,0.8);
            padding: 10px 18px;
            border-radius: 30px;
            cursor: pointer;
            transition: 0.2s;
            font-size: 15px;
            display: flex; align-items: center; gap: 6px;
            outline: none;
        }

        .btn:hover { background: rgba(255,255,255,0.2); color: white; transform: translateY(-2px); }
        .btn.active { background: var(--primary-color); border-color: var(--primary-color); color: white; box-shadow: 0 0 15px var(--primary-color); }
        
        /* é¢œè‰²é€‰æ‹©å™¨ç¾åŒ– */
        .color-wrapper {
            width: 36px; height: 36px; border-radius: 50%; overflow: hidden; border: 2px solid rgba(255,255,255,0.5); cursor: pointer; transition: 0.3s;
        }
        .color-wrapper:hover { border-color: white; transform: scale(1.1); }
        input[type="color"] { border: none; width: 200%; height: 200%; cursor: pointer; background: none; padding: 0; transform: translate(-25%, -25%); }
        
        /* å…¨å±æŒ‰é’® */
        #fs-btn { 
            position: absolute; top: 20px; right: 20px; z-index: 11; 
            width: 44px; height: 44px; border-radius: 50%; font-size: 22px; 
            padding: 0; display: flex; justify-content: center; align-items: center;
        }

        /* åŠ è½½æç¤º */
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; z-index: 20; font-size: 18px; letter-spacing: 1px;
            text-align: center;
            text-shadow: 0 0 10px rgba(255,105,180,0.7); pointer-events: none;
        }
        #loading .spinner {
            margin: 0 auto 20px; width: 40px; height: 40px;
            border: 3px solid rgba(255,255,255,0.3); border-top-color: var(--primary-color);
            border-radius: 50%; animation: spin 1s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <div id="canvas-container"></div>
    
    <div id="camera-container" class="glass-panel">
        <video id="video-input"></video>
    </div>
    
    <div id="loading">
        <div class="spinner"></div>
        æ­£åœ¨å¯åŠ¨è§†è§‰å¼•æ“...<br>è¯·æˆäºˆæ‘„åƒå¤´æƒé™ä»¥ä½“éªŒäº’åŠ¨
    </div>

    <button id="fs-btn" class="btn glass-panel">â›¶</button>

    <div id="ui-panel" class="glass-panel">
        <button class="btn active" onclick="setShape('heart')">â¤ çˆ±å¿ƒ</button>
        <button class="btn" onclick="setShape('galaxy')">ğŸŒŒ æ˜Ÿç³»</button>
        <button class="btn" onclick="setShape('saturn')">ğŸª åœŸæ˜Ÿ</button>
        <button class="btn" onclick="setShape('flower')">ğŸŒ¸ èŠ±æœµ</button>
        <div style="width:1px; height:24px; background:rgba(255,255,255,0.2); margin: 0 5px;"></div>
        <div class="color-wrapper" title="è°ƒæ•´ç²’å­é¢œè‰²">
             <input type="color" id="color-picker" value="#ff69b4">
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/hands": "https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js",
                "@mediapipe/camera_utils": "https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- 1. åˆå§‹åŒ–åœºæ™¯ ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        // ç§»é™¤ä¹‹å‰çš„Fogï¼ŒèƒŒæ™¯æ”¹ç”¨CSSå¾„å‘æ¸å˜ï¼Œæ›´é€šé€
        
        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.z = 45; // ç¨å¾®æ‹‰è¿œä¸€ç‚¹è§†è§’

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // é™åˆ¶åƒç´ æ¯”ï¼Œæå‡æ€§èƒ½
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.8; // åŸºç¡€æ—‹è½¬é€Ÿåº¦

        // --- 2. é«˜æ€§èƒ½ç²’å­ç³»ç»Ÿ (Shaderå¢å¼ºç‰ˆ) ---
        const PARTICLE_COUNT = 40000; // å¢åŠ ç²’å­æ•°é‡
        const geometry = new THREE.BufferGeometry();
        
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const targets = new Float32Array(PARTICLE_COUNT * 3);
        const randoms = new Float32Array(PARTICLE_COUNT * 3);
        const colors = new Float32Array(PARTICLE_COUNT * 3); // æ¯ä¸ªç²’å­å¯ä»¥æœ‰å¾®å°çš„é¢œè‰²å·®å¼‚
        
        const baseColor = new THREE.Color('#ff69b4');
        
        for(let i=0; i<PARTICLE_COUNT; i++) {
            const i3 = i * 3;
            positions[i3] = (Math.random() - 0.5) * 150;
            positions[i3+1] = (Math.random() - 0.5) * 150;
            positions[i3+2] = (Math.random() - 0.5) * 150;
            
            randoms[i3] = Math.random(); 
            randoms[i3+1] = Math.random();
            randoms[i3+2] = Math.random();

            // ç»™æ¯ä¸ªç²’å­ä¸€ä¸ªåŸºç¡€é¢œè‰²çš„å¾®è°ƒï¼Œæ›´ä¸°å¯Œ
            const colorStyle = baseColor.clone().offsetHSL(Math.random() * 0.1 - 0.05, 0, 0);
            colors[i3] = colorStyle.r;
            colors[i3+1] = colorStyle.g;
            colors[i3+2] = colorStyle.b;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('target', new THREE.BufferAttribute(targets, 3));
        geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 3));
        geometry.setAttribute('aColor', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uGlobalColor: { value: new THREE.Color('#ff69b4') },
                uMorph: { value: 0 }, 
                uHandScale: { value: 1.0 }, 
                uHandDisplace: { value: 0.0 },
                uFlipRot: { value: 0.0 } // æ–°å¢ï¼šç¿»è½¬æ—‹è½¬è§’åº¦
            },
            vertexShader: `
                uniform float uTime;
                uniform float uMorph;
                uniform float uHandScale;
                uniform float uHandDisplace;
                uniform float uFlipRot;
                
                attribute vec3 target;
                attribute vec3 aRandom;
                attribute vec3 aColor;
                
                varying vec3 vColor;
                varying float vAlpha;

                // æ—‹è½¬çŸ©é˜µå‡½æ•°
                mat2 rotate2d(float _angle){
                    return mat2(cos(_angle),-sin(_angle),
                                sin(_angle),cos(_angle));
                }

                void main() {
                    vColor = aColor;

                    // 1. Morphing æ’å€¼
                    vec3 pos = mix(position, target, uMorph);
                    
                    // 2. æ›´å¤æ‚çš„å™ªå£°æµ®åŠ¨æ•ˆæœ (æ¨¡æ‹Ÿç©ºæ°”æ‰°åŠ¨)
                    float timeScale = uTime * 1.5;
                    pos.x += sin(timeScale + aRandom.y * 6.28) * 0.3 * aRandom.x;
                    pos.y += cos(timeScale + aRandom.z * 6.28) * 0.3 * aRandom.y;
                    pos.z += sin(timeScale + aRandom.x * 6.28) * 0.3 * aRandom.z;

                    // 3. æ‰‹åŠ¿æ§åˆ¶ï¼šæ•´ä½“ç¼©æ”¾ (åº”ç”¨åœ¨æ—‹è½¬å‰)
                    pos *= uHandScale;

                    // 4. æ‰‹åŠ¿æ§åˆ¶ï¼šç¿»è½¬ç‰¹æ•ˆ (ç»•Yè½´æ—‹è½¬)
                    float flipS = sin(uFlipRot);
                    float flipC = cos(uFlipRot);
                    mat2 flipMat = mat2(flipC, -flipS, flipS, flipC);
                    pos.xz = flipMat * pos.xz;

                    // 5. æ‰‹åŠ¿æ§åˆ¶ï¼šç‚¸è£‚/æ‰©æ•£ (åº”ç”¨åœ¨æ—‹è½¬åï¼Œç¡®ä¿æ–¹å‘æ­£ç¡®)
                    // ä½¿ç”¨åŸå§‹ä½ç½®çš„æ³•çº¿æ–¹å‘ï¼Œè®©çˆ†ç‚¸æ›´å…·çˆ†å‘åŠ›
                    vec3 explosionDir = normalize(pos + vec3(0.001)); 
                    pos += explosionDir * uHandDisplace * 25.0;

                    // 6. è‡ªèº«å¾®å¦™æ—‹è½¬
                    pos.xz = rotate2d(uTime * 0.05 * (aRandom.x - 0.5)) * pos.xz;

                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    
                    // ç²’å­å¤§å°éšè·ç¦»å’Œæ‰‹åŠ¿å˜åŒ–
                    float baseSize = 3.5 * uHandScale;
                    // æåˆçˆ†ç‚¸æ—¶ç²’å­å˜å¤§
                    baseSize += uHandDisplace * 2.0; 
                    gl_PointSize = baseSize * (35.0 / -mvPosition.z);
                    
                    gl_Position = projectionMatrix * mvPosition;
                    
                    // è¾¹ç¼˜ç²’å­é€æ˜åº¦å˜åŒ–
                    vAlpha = smoothstep(100.0, 0.0, length(pos)) * 0.9 + 0.1;
                }
            `,
            fragmentShader: `
                uniform vec3 uGlobalColor;
                varying vec3 vColor;
                varying float vAlpha;

                void main() {
                    vec2 coord = gl_PointCoord - vec2(0.5);
                    float dist = length(coord);
                    
                    // æŸ”è½¯çš„åœ†å½¢å…‰æ™•
                    float glow = 1.0 - smoothstep(0.0, 0.5, dist);
                    glow = pow(glow, 2.0); 
                    if (dist > 0.5) discard;

                    // æ··åˆå›ºæœ‰è‰²å’Œå…¨å±€æ§åˆ¶è‰²
                    vec3 finalColor = mix(vColor, uGlobalColor, 0.7);
                    
                    // æ ¸å¿ƒæ›´äº®
                    finalColor += vec3(glow * 0.5);

                    gl_FragColor = vec4(finalColor, vAlpha * glow);
                }
            `,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending 
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- 3. å½¢çŠ¶ç”Ÿæˆå…¬å¼ (ä¼˜åŒ–ç‰ˆ) ---
        const shapes = {
            heart: (i, total) => {
                const theta = Math.random() * Math.PI;
                const phi = Math.random() * Math.PI * 2;
                // æ›´é¥±æ»¡çš„å¿ƒå½¢å‚æ•°
                let x = 16 * Math.pow(Math.sin(theta), 3) * Math.cos(phi);
                let y = 13 * Math.cos(theta) - 5 * Math.cos(2*theta) - 2 * Math.cos(3*theta) - Math.cos(4*theta);
                let z = 16 * Math.pow(Math.sin(theta), 3) * Math.sin(phi) * 0.6;
                // å¢åŠ ä¸€äº›éšæœºæ•£å¸ƒ
                const p = new THREE.Vector3(x, y, z).multiplyScalar(0.9);
                p.addScaledVector(new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5), 1.5);
                return p;
            },
            galaxy: (i, total) => {
                // å¸¦æœ‰ä¸­å¿ƒæ ¸çš„æ—‹æ¶¡æ˜Ÿç³»
                const arms = 5;
                const spin = i / total * arms * Math.PI * 2;
                const radius = Math.pow(Math.random(), 1.5) * 35; // å¹‚å‡½æ•°è®©ä¸­å¿ƒæ›´å¯†é›†
                
                const x = Math.cos(spin) * radius;
                const y = (Math.random() - 0.5) * (radius * 0.1 + 2); // éšåŠå¾„å¢åŠ åšåº¦
                const z = Math.sin(spin) * radius;
                
                const p = new THREE.Vector3(x, y, z);
                // å¢åŠ æ—‹è‡‚ä¸Šçš„éšæœºæ‰°åŠ¨
                p.x += (Math.random()-0.5) * 3;
                p.z += (Math.random()-0.5) * 3;
                return p;
            },
            saturn: (i, total) => {
                if (i < total * 0.65) {
                    // æ˜Ÿçƒæœ¬ä½“
                    const r = 9;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos((Math.random() * 2) - 1);
                    return new THREE.Vector3(
                        r * Math.sin(phi) * Math.cos(theta),
                        r * Math.sin(phi) * Math.sin(theta),
                        r * Math.cos(phi)
                    );
                } else {
                    // å…‰ç¯ (æ›´å¯†é›†ä¸”æœ‰å®½åº¦)
                    const angle = Math.random() * Math.PI * 2;
                    const rMin = 13, rMax = 22;
                    const r = rMin + Math.random() * (rMax - rMin);
                    return new THREE.Vector3(
                        Math.cos(angle) * r,
                        (Math.random() - 0.5) * 0.8, // éå¸¸è–„
                        Math.sin(angle) * r
                    );
                }
            },
            flower: (i, total) => {
                // ç«ç‘°èŠ±çƒ
                const u = Math.random() * Math.PI;
                const v = Math.random() * Math.PI * 2;
                const k = 3; // èŠ±ç“£ç³»æ•°
                const r = 15 * Math.sin(k * u); // èŠ±ç“£å½¢çŠ¶åŠå¾„
                
                // çƒåæ ‡è½¬æ¢
                const x = r * Math.sin(u) * Math.cos(v);
                const y = r * Math.sin(u) * Math.sin(v);
                const z = r * Math.cos(u);
                
                return new THREE.Vector3(x, y, z).multiplyScalar(1.2);
            }
        };

        // å½¢çŠ¶åˆ‡æ¢é€»è¾‘
        let animateMorph = true;
        window.setShape = (shapeName) => {
            document.querySelectorAll('#ui-panel .btn').forEach(b => b.classList.remove('active'));
            event.currentTarget.classList.add('active');

            const targetAttr = geometry.attributes.target;
            for(let i=0; i<PARTICLE_COUNT; i++) {
                const vec = shapes[shapeName](i, PARTICLE_COUNT);
                targetAttr.setXYZ(i, vec.x, vec.y, vec.z);
            }
            targetAttr.needsUpdate = true;
            
            material.uniforms.uMorph.value = 0;
            animateMorph = true;
        };

        // åˆå§‹å½¢çŠ¶
        const targetAttr = geometry.attributes.target;
        for(let i=0; i<PARTICLE_COUNT; i++) {
            const vec = shapes.heart(i, PARTICLE_COUNT);
            targetAttr.setXYZ(i, vec.x, vec.y, vec.z);
        }
        targetAttr.needsUpdate = true;

        // --- 4. é«˜çµæ•åº¦æ‰‹åŠ¿è¯†åˆ« (MediaPipe) ---
        
        // ç›®æ ‡å€¼ï¼ˆæœªç»å¹³æ»‘ï¼‰
        let targetScale = 1.0;
        let targetDisplace = 0.0;
        let targetFlipRot = 0.0;

        let isHandsVisible = false;
        let isCrossingHands = false; // æ˜¯å¦äº¤å‰åŒæ‰‹

        async function initMediaPipe() {
            const { Hands } = window;
            const { Camera } = window;

            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});

            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.6, // æé«˜ç½®ä¿¡åº¦é˜ˆå€¼ï¼Œå‡å°‘è¯¯åˆ¤
                minTrackingConfidence: 0.6
            });

            hands.onResults(onResults);

            const videoElement = document.getElementById('video-input');
            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 320, // é™ä½è¾“å…¥åˆ†è¾¨ç‡ä»¥æé«˜å¤„ç†é€Ÿåº¦
                height: 240
            });
            
            cameraUtils.start()
                .then(() => {
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('camera-container').classList.add('active');
                })
                .catch(e => {
                     document.getElementById('loading').innerHTML = 'âŒ æ‘„åƒå¤´å¯åŠ¨å¤±è´¥<br>è¯·æ£€æŸ¥æµè§ˆå™¨æƒé™è®¾ç½®';
                });
        }

        function onResults(results) {
            const numHands = results.multiHandLandmarks.length;
            isHandsVisible = numHands > 0;

            if (numHands === 2) {
                // --- åŒæ‰‹æ¨¡å¼ï¼šç¼©æ”¾ & ç¿»è½¬ ---
                const hand1 = results.multiHandLandmarks[0];
                const hand2 = results.multiHandLandmarks[1];
                const wrist1 = hand1[0];
                const wrist2 = hand2[0];

                // 1. è®¡ç®—è·ç¦»æ§åˆ¶ç¼©æ”¾
                // ä½¿ç”¨ä¸‰ç»´è·ç¦»è®¡ç®—æ›´å‡†ç¡®
                const dist = Math.sqrt(
                    Math.pow(wrist1.x - wrist2.x, 2) + 
                    Math.pow(wrist1.y - wrist2.y, 2) +
                    Math.pow(wrist1.z - wrist2.z, 2)
                );
                
                // æ˜ å°„è·ç¦»åˆ°ç¼©æ”¾å€æ•° (è°ƒæ•´æ˜ å°„èŒƒå›´ä»¥æé«˜çµæ•åº¦)
                // 0.1 (è¿‘) -> 0.4å€, 0.6 (è¿œ) -> 2.2å€
                targetScale = THREE.MathUtils.mapLinear(dist, 0.1, 0.6, 0.4, 2.2);
                targetScale = THREE.MathUtils.clamp(targetScale, 0.3, 2.5); // é™åˆ¶èŒƒå›´

                // 2. æ£€æµ‹åŒæ‰‹äº¤å‰ (ç¿»è½¬è§¦å‘)
                // ç®€å•åˆ¤æ–­ï¼šå¦‚æœä¸¤ä¸ªæ‰‹è…•çš„Xåæ ‡éå¸¸æ¥è¿‘ï¼Œæˆ–è€…é¡ºåºå‘ç”Ÿäº†å˜åŒ–
                // ç”±äº MediaPipe è¾“å‡ºçš„æ‰‹é¡ºåºä¸å›ºå®šï¼Œæˆ‘ä»¬åˆ¤æ–­æ¨ªå‘è·ç¦»æ˜¯å¦å°äºä¸€ä¸ªé˜ˆå€¼
                const xDist = Math.abs(wrist1.x - wrist2.x);
                
                if (xDist < 0.1) { // é˜ˆå€¼ï¼ŒåŒæ‰‹é å¾—å¾ˆè¿‘æˆ–äº¤å‰
                    if (!isCrossingHands) {
                        isCrossingHands = true;
                        // è§¦å‘ç¿»è½¬ï¼šç›®æ ‡æ—‹è½¬è§’åº¦å¢åŠ  180åº¦ (PI)
                        targetFlipRot = material.uniforms.uFlipRot.value + Math.PI;
                    }
                } else if (xDist > 0.2) { // é˜ˆå€¼ï¼ŒåŒæ‰‹åˆ†å¼€
                     isCrossingHands = false;
                }

                targetDisplace = 0.0;
                controls.autoRotateSpeed = 1.2; // åŒæ‰‹æ—¶ç¨å¿«æ—‹è½¬

            } else if (numHands === 1) {
                // --- å•æ‰‹æ¨¡å¼ï¼šæåˆ/ç‚¸è£‚ ---
                const hand = results.multiHandLandmarks[0];
                const thumbTip = hand[4];
                const indexTip = hand[8];
                
                const pinchDist = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) + 
                    Math.pow(thumbTip.y - indexTip.y, 2)
                );

                // æ˜ å°„æåˆè·ç¦»åˆ°æ‰©æ•£åŠ›åº¦ (é«˜çµæ•åº¦)
                // è·ç¦» > 0.08 å¼€å§‹æ‰©æ•£ï¼Œæœ€å¤§æ‰©æ•£åŠ›åº¦æ›´å¤§
                if (pinchDist > 0.08) {
                    targetDisplace = (pinchDist - 0.08) * 8.0;
                } else {
                    targetDisplace = 0.0;
                }
                targetScale = 1.0;
                controls.autoRotateSpeed = 2.5; // å•æ‰‹æ“ä½œæ—¶èƒŒæ™¯æ—‹è½¬åŠ å¿«ï¼Œå¢åŠ åŠ¨æ„Ÿ

            } else {
                // --- æ— æ‰‹åŠ¿å¤ä½ ---
                targetScale = 1.0;
                targetDisplace = 0.0;
                // ä¿æŒå½“å‰çš„ç¿»è½¬è§’åº¦ç›®æ ‡ï¼Œä¸å¤ä½
                controls.autoRotateSpeed = 0.8;
            }
        }

        // å»¶è¿ŸåŠ è½½è§†è§‰åº“
        setTimeout(() => {
            const script = document.createElement('script');
            script.src = "https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js";
            script.onload = () => {
                 const camScript = document.createElement('script');
                 camScript.src = "https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js";
                 camScript.onload = initMediaPipe;
                 document.body.appendChild(camScript);
            };
            document.body.appendChild(script);
        }, 500);


        // --- 5. äº¤äº’ä¸åŠ¨ç”»å¾ªç¯ ---
        
        // é¢œè‰²é€‰æ‹©
        const colorPicker = document.getElementById('color-picker');
        const targetColor = new THREE.Color(colorPicker.value);
        colorPicker.addEventListener('input', (e) => {
            targetColor.set(e.target.value);
            document.querySelector('.color-wrapper').style.borderColor = e.target.value;
        });

        // å…¨å±
        document.getElementById('fs-btn').addEventListener('click', () => {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen();
            else document.exitFullscreen();
        });

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            const time = clock.getElapsedTime();

            material.uniforms.uTime.value = time;
            material.uniforms.uGlobalColor.value.lerp(targetColor, 0.08);

            // --- æ ¸å¿ƒï¼šé«˜çµæ•åº¦å¹³æ»‘è¿‡æ¸¡ ---
            // æé«˜ lerp ç³»æ•° (ä» 0.1 æé«˜åˆ° 0.35)ï¼Œè®©è·Ÿéšæ›´ç´§å¯†
            const sensitivity = 0.35; 
            material.uniforms.uHandScale.value += (targetScale - material.uniforms.uHandScale.value) * sensitivity;
            material.uniforms.uHandDisplace.value += (targetDisplace - material.uniforms.uHandDisplace.value) * sensitivity;

            // ç¿»è½¬è§’åº¦å¹³æ»‘è¿‡æ¸¡ (ç¨å¾®æ…¢ä¸€ç‚¹ï¼Œçœ‹èµ·æ¥æ›´ä¼˜é›…)
            material.uniforms.uFlipRot.value += (targetFlipRot - material.uniforms.uFlipRot.value) * 0.1;

            // å½¢çŠ¶å˜å½¢é€»è¾‘
            if (animateMorph) {
                material.uniforms.uMorph.value += dt * 0.7; // å˜å½¢é€Ÿåº¦
                if (material.uniforms.uMorph.value >= 1.0) {
                    material.uniforms.uMorph.value = 1.0;
                    animateMorph = false;
                    // å®Œæˆå˜å½¢åï¼Œæ›´æ–°position buffer
                    const posArr = geometry.attributes.position.array;
                    const targetArr = geometry.attributes.target.array;
                    for(let i=0; i<posArr.length; i++) posArr[i] = targetArr[i];
                    geometry.attributes.position.needsUpdate = true;
                    material.uniforms.uMorph.value = 0.0;
                }
            }

            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
