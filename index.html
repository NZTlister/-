<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Hand Particles - Fantastic Shapes</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; color: white; font-family: monospace; }
        
        #debug-console {
            position: absolute; top: 0; left: 0; width: 100%; height: 50px;
            background: rgba(20, 0, 0, 0.8); pointer-events: none;
            z-index: 999; padding: 10px; box-sizing: border-box;
            overflow-y: scroll; border-bottom: 1px solid #ff000055;
            font-size: 12px;
            /* æˆåŠŸåè‡ªåŠ¨éšè— */
            transition: opacity 1s;
        }

        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        #video-input { position: absolute; bottom: 10px; right: 10px; width: 100px; transform: scaleX(-1); z-index: 5; display: none; border-radius: 8px; border: 1px solid #555; }
        
        #start-btn {
            position: absolute; bottom: 30%; left: 50%; transform: translateX(-50%);
            padding: 12px 35px; font-size: 16px; border-radius: 25px;
            background: rgba(0, 210, 255, 0.3); color: #00d2ff; border: 1px solid #00d2ff; 
            cursor: pointer; z-index: 100; display: none;
            backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px);
        }
    </style>

    <script>
        function log(msg) {
            const box = document.getElementById('debug-console');
            if(box) { box.innerHTML = `> ${msg}`; }
            console.log(msg);
        }
        window.onerror = (msg) => log(`âŒ ERROR: ${msg}`);
    </script>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.esm.min.js"
            }
        }
    </script>
</head>
<body>
    <div id="debug-console">â³ åˆå§‹åŒ–ä¸­...</div>
    <button id="start-btn">å¼€å¯æ‘„åƒå¤´ä½“éªŒ (START)</button>
    <video id="video-input" playsinline></video>
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import GUI from 'lil-gui';

        log("ğŸ“¦ æ¨¡å—åŠ è½½å®Œæ¯•ï¼Œæ­£åœ¨ç­‰å¾… MediaPipe...");

        let scene, camera, renderer, particles, geometry, material;
        let positionsOriginal = [], handScaleFactor = 1.0, isRunning = false;
        const startBtn = document.getElementById('start-btn');
        const debugBox = document.getElementById('debug-console');
        const PARTICLE_COUNT = 6000; // ç²’å­æ•°é‡

        // --- èµ„æºæ£€æµ‹ ---
        const checkTimer = setInterval(() => {
            if (window.Hands && window.Camera) {
                clearInterval(checkTimer);
                log("âœ… èµ„æºå°±ç»ªã€‚è¯·ç‚¹å‡»æŒ‰é’®å¯åŠ¨ã€‚");
                startBtn.style.display = 'block';
                setTimeout(() => debugBox.style.opacity = 0, 3000); // 3ç§’åéšè—æ—¥å¿—
            }
        }, 500);

        // --- å¯åŠ¨ ---
        startBtn.addEventListener('click', async () => {
            startBtn.style.display = 'none';
            log("ğŸš€ æ­£åœ¨å¯åŠ¨æ‘„åƒå¤´...");
            try {
                const hands = new window.Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
                hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
                hands.onResults(onHandResults);

                const video = document.getElementById('video-input');
                const cameraUtils = new window.Camera(video, {
                    onFrame: async () => { await hands.send({image: video}); },
                    width: 640, height: 480, facingMode: "user"
                });
                await cameraUtils.start();
                
                video.style.display = 'block';
                initThree();
                animate();
                isRunning = true;
                log(""); debugBox.style.display='none'; // å½»åº•éšè—

            } catch (e) {
                log("âŒ å¯åŠ¨å¤±è´¥: " + e.message); alert(e.message); startBtn.style.display = 'block';
            }
        });

        // --- Three.js ---
        function initThree() {
            scene = new THREE.Scene();
            // æ·»åŠ ä¸€ç‚¹ç¯å¢ƒé›¾æ°”ï¼Œå¢åŠ æ·±é‚ƒæ„Ÿ
            scene.fog = new THREE.FogExp2(0x000000, 0.015);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.z = 25; // ç›¸æœºæ‹‰è¿œä¸€ç‚¹çœ‹å¤§åœºæ™¯

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true; // å¼€å¯è‡ªåŠ¨æ—‹è½¬
            controls.autoRotateSpeed = 0.5;

            // åˆå§‹åŒ–ç²’å­ç³»ç»Ÿ
            geometry = new THREE.BufferGeometry();
            const pos = new Float32Array(PARTICLE_COUNT * 3);
            geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));

            // ç”Ÿæˆå‘å…‰çº¹ç†
            const cvs = document.createElement('canvas'); cvs.width=32; cvs.height=32;
            const ctx = cvs.getContext('2d');
            const grd = ctx.createRadialGradient(16,16,0,16,16,16);
            grd.addColorStop(0,'rgba(255,255,255,1)'); grd.addColorStop(0.4,'rgba(200,255,255,0.3)'); grd.addColorStop(1,'rgba(0,0,0,0)');
            ctx.fillStyle = grd; ctx.fillRect(0,0,32,32);
            const tex = new THREE.Texture(cvs); tex.needsUpdate = true;

            material = new THREE.PointsMaterial({ 
                size: 0.2, map: tex, color: 0x00d2ff, 
                transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending, depthWrite: false 
            });
            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // é»˜è®¤å½¢çŠ¶
            updateShape('Galaxy');

            // GUI æ§åˆ¶é¢æ¿
            const gui = new GUI();
            gui.domElement.style.marginTop = "10px";
            const config = { shape: 'Galaxy', color: '#00d2ff' };
            gui.add(config, 'shape', ['Galaxy', 'Heart', 'Nebula', 'Spiral', 'Sphere']).name('åˆ‡æ¢å½¢çŠ¶').onChange(v => updateShape(v));
            gui.addColor(config, 'color').name('ç²’å­é¢œè‰²').onChange(v => material.color.set(v));

            window.addEventListener('resize', onResize);
        }

        // --- æ ¸å¿ƒï¼šå½¢çŠ¶ç”Ÿæˆå…¬å¼ ---
        function updateShape(type) {
            const count = PARTICLE_COUNT;
            const arr = new Float32Array(count * 3);
            for(let i=0; i<count; i++) {
                let x,y,z, r, a, phi, theta;
                const i3 = i*3;
                const random = Math.random(); // é¢„è®¡ç®—éšæœºæ•°

                switch(type) {
                    case 'Galaxy': // é“¶æ²³ç³»
                        // å¢åŠ æ—‹è‡‚æ•°é‡å’Œéšæœºæ€§
                        const arms = 5;
                        const spin = i * 0.001;
                        const armIndex = i % arms;
                        r = random * 15; // åŠå¾„
                        a = spin + (Math.PI * 2 / arms) * armIndex; // è§’åº¦
                        x = Math.cos(a) * r;
                        y = (Math.random() - 0.5) * (r * 0.1 + 0.5); // ä¸­å¿ƒæ‰å¹³
                        z = Math.sin(a) * r;
                        // å¢åŠ ä¸€ç‚¹éšæœºæ•£å°„
                        x += (Math.random()-0.5) * 0.5; z += (Math.random()-0.5) * 0.5;
                        break;

                    case 'Heart': // 3Dçˆ±å¿ƒ
                        phi = Math.acos( -1 + ( 2 * i ) / count );
                        theta = Math.sqrt( count * Math.PI ) * phi;
                        // çˆ±å¿ƒå‚æ•°æ–¹ç¨‹
                        x = 16 * Math.pow(Math.sin(theta), 3);
                        y = 13 * Math.cos(theta) - 5 * Math.cos(2 * theta) - 2 * Math.cos(3 * theta) - Math.cos(4 * theta);
                        z = 6 * Math.cos(phi); // ç¨å¾®å‹æ‰ä¸€ç‚¹zè½´
                        // ç¼©æ”¾
                        x *= 0.4; y *= 0.4; z *= 0.4;
                        break;
                    
                    case 'Nebula': // æ˜Ÿäº‘ (å¤æ‚æ³¢å½¢)
                        r = 5 + random * 10;
                        theta = random * Math.PI * 2;
                        phi = random * Math.PI;
                        // ä½¿ç”¨å¤šä¸ªä¸åŒé¢‘ç‡çš„æ­£å¼¦æ³¢å åŠ 
                        const wave1 = Math.sin(i * 0.01) * 2;
                        const wave2 = Math.cos(i * 0.025) * 3;
                        x = (r + wave1) * Math.sin(phi) * Math.cos(theta);
                        y = (r + wave2) * Math.sin(phi) * Math.sin(theta) * 0.6; // å‹æ‰
                        z = r * Math.cos(phi) * 0.8;
                        break;

                    case 'Spiral': // å·¨å¤§çš„èºæ—‹ç»“æ„
                        r = i * 0.005; // åŠå¾„éšç´¢å¼•å¢åŠ 
                        a = i * 0.05;  // è§’åº¦éšç´¢å¼•å¢åŠ 
                        x = r * Math.cos(a);
                        y = (random - 0.5) * 2; // yè½´éšæœºåˆ†å¸ƒ
                        z = r * Math.sin(a);
                        break;

                    default: // Sphere (çƒä½“ - é»˜è®¤)
                        r = 10;
                        phi = Math.acos( -1 + ( 2 * i ) / count );
                        theta = Math.sqrt( count * Math.PI ) * phi;
                        x = r * Math.sin(phi) * Math.cos(theta);
                        y = r * Math.sin(phi) * Math.sin(theta);
                        z = r * Math.cos(phi);
                        break;
                }
                // ç»Ÿä¸€å†™å…¥æ•°ç»„
                arr[i3] = x; arr[i3+1] = y; arr[i3+2] = z;
            }
            positionsOriginal = arr; // æ›´æ–°ç›®æ ‡ä½ç½®
        }

        function animate() {
            if(!isRunning) return;
            requestAnimationFrame(animate);
            const pos = particles.geometry.attributes.position.array;
            // ç¼“åŠ¨åŠ¨ç”»ï¼šå½“å‰ä½ç½® -> ç›®æ ‡ä½ç½® * æ‰‹åŠ¿ç¼©æ”¾
            for(let i=0; i<pos.length; i++) {
                pos[i] += (positionsOriginal[i] * handScaleFactor - pos[i]) * 0.08;
            }
            particles.geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }

        function onHandResults(res) {
            if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
                const lm = res.multiHandLandmarks[0];
                const d = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                // æ˜ å°„è·ç¦»åˆ°ç¼©æ”¾ç³»æ•° (0.3 ~ 2.5)
                const target = 0.3 + Math.min(Math.max((d-0.02)/0.2,0),1) * 2.2;
                handScaleFactor += (target - handScaleFactor) * 0.1;
            } else {
                handScaleFactor += (1.0 - handScaleFactor) * 0.05;
            }
        }
        
        function onResize() {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
