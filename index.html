<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Three.js 手势交互粒子系统</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
        }
        #container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        /* 隐藏原始视频流和 MediaPipe 辅助 Canvas */
        .input_video, .output_canvas {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            z-index: -1;
        }
        /* 全屏按钮样式 */
        #fullscreen-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.4);
            color: white;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 8px;
            transition: background 0.3s;
            backdrop-filter: blur(5px);
        }
        #fullscreen-btn:hover {
            background: rgba(255, 255, 255, 0.4);
        }
        /* 加载提示 */
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            z-index: 200;
            pointer-events: none;
        }
    </style>
</head>
<body>

<video class="input_video"></video>
<canvas class="output_canvas" width="1280px" height="720px"></canvas>

<div id="loading">正在启动摄像头和模型，请稍候...</div>
<button id="fullscreen-btn">⛶ 全屏模式</button>
<div id="container"></div>

<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/"
    }
  }
</script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/lil-gui@0.17.0/dist/lil-gui.umd.min.js"></script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

// --- 全局变量 ---
let scene, camera, renderer, controls;
let particleSystem1, particleSystem2;
let handResults = null;
const PARTICLE_COUNT = 3000; // 每个系统的粒子数量

// 手势状态存储 (0 = 握拳, 1 = 张开)
const handState = {
    leftHandOpenness: 0.5,
    rightHandOpenness: 0.5
};

// UI 配置参数
const params = {
    shape1: 'Heart',
    color1: '#ff0055',
    shape2: 'Galaxy',
    color2: '#0055ff'
};

const shapeOptions = ['Heart', 'Flower', 'Saturn', 'Fireworks', 'Galaxy'];

// --- 初始化 ---
initThree();
initUI();
initMediaPipe();
animate();

// --- 1. Three.js 场景设置 ---
function initThree() {
    const container = document.getElementById('container');
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.0008);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.position.z = 800;

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000, 1);
    container.appendChild(renderer.domElement);

    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.5;

    // 创建两个粒子系统
    particleSystem1 = createParticleSystem(params.color1, getShapeData(params.shape1));
    particleSystem2 = createParticleSystem(params.color2, getShapeData(params.shape2));
    
    // 将它们稍微分开摆放
    particleSystem1.mesh.position.x = -250;
    particleSystem2.mesh.position.x = 250;

    scene.add(particleSystem1.mesh);
    scene.add(particleSystem2.mesh);

    window.addEventListener('resize', onWindowResize);

    // 全屏按钮事件
    const fsBtn = document.getElementById('fullscreen-btn');
    fsBtn.addEventListener('click', () => {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen();
            fsBtn.textContent = "⛶ 退出全屏";
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
                fsBtn.textContent = "⛶ 全屏模式";
            }
        }
    });
}

// --- 2. 粒子系统核心逻辑 ---
function createParticleSystem(colorStr, basePositions) {
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(PARTICLE_COUNT * 3);
    // 用于存储每个粒子的原始基础位置，以便基于此进行缩放
    const initialPositions = new Float32Array(PARTICLE_COUNT * 3);
    
    // 初始化位置
    for (let i = 0; i < PARTICLE_COUNT; i++) {
        const pos = basePositions[i % basePositions.length];
        // 添加一些随机抖动让分布更自然
        const x = pos.x + (Math.random() - 0.5) * 10;
        const y = pos.y + (Math.random() - 0.5) * 10;
        const z = pos.z + (Math.random() - 0.5) * 10;
        
        positions[i * 3] = x;
        positions[i * 3 + 1] = y;
        positions[i * 3 + 2] = z;

        initialPositions[i * 3] = x;
        initialPositions[i * 3 + 1] = y;
        initialPositions[i * 3 + 2] = z;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('initialPosition', new THREE.BufferAttribute(initialPositions, 3));

    // 使用圆形纹理的材质
    const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');
    const material = new THREE.PointsMaterial({
        size: 6,
        color: new THREE.Color(colorStr),
        map: sprite,
        blending: THREE.AdditiveBlending, // 发光叠加效果
        depthTest: false,
        transparent: true,
        opacity: 0.8
    });

    const mesh = new THREE.Points(geometry, material);
    return { mesh, geometry, material };
}

// 更新粒子系统形状
function updateParticleShape(system, shapeName) {
    const newBasePositions = getShapeData(shapeName);
    const initialPositions = system.geometry.attributes.initialPosition.array;
    
    for (let i = 0; i < PARTICLE_COUNT; i++) {
        const pos = newBasePositions[i % newBasePositions.length];
        initialPositions[i * 3] = pos.x + (Math.random() - 0.5) * 10;
        initialPositions[i * 3 + 1] = pos.y + (Math.random() - 0.5) * 10;
        initialPositions[i * 3 + 2] = pos.z + (Math.random() - 0.5) * 10;
    }
    system.geometry.attributes.initialPosition.needsUpdate = true;
}

// 根据手势张开程度更新粒子位置 (核心交互逻辑)
function updateSystemByHand(system, opennessFactor) {
    const positions = system.geometry.attributes.position.array;
    const initialPositions = system.geometry.attributes.initialPosition.array;
    
    // 映射 opennessFactor (0~1) 到一个缩放比例 (例如 0.2倍 到 2.5倍)
    // 使用平滑插值让动作更跟手
    const targetScale = THREE.MathUtils.lerp(0.2, 2.5, opennessFactor);
    system.currentScale = THREE.MathUtils.lerp(system.currentScale || 1, targetScale, 0.1);

    for (let i = 0; i < PARTICLE_COUNT; i++) {
        positions[i * 3] = initialPositions[i * 3] * system.currentScale;
        positions[i * 3 + 1] = initialPositions[i * 3 + 1] * system.currentScale;
        positions[i * 3 + 2] = initialPositions[i * 3 + 2] * system.currentScale;
    }
    system.geometry.attributes.position.needsUpdate = true;
    
    // 缓慢自转增加动感
    system.mesh.rotation.y += 0.002;
}


// --- 3. 形状生成数学公式 ---
function getShapeData(type) {
    const points = [];
    const count = 2000; // 采样点数量
    switch (type) {
        case 'Heart':
            for (let i = 0; i < count; i++) {
                const t = (i / count) * Math.PI * 2;
                // 心形参数方程
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                const z = (Math.random() - 0.5) * 10; // 少量厚度
                points.push(new THREE.Vector3(x * 10, y * 10, z));
            }
            break;
        case 'Flower':
            for (let i = 0; i < count; i++) {
                const t = (i / count) * Math.PI * 2;
                const r = 150 * Math.sin(5 * t); // 5瓣花
                points.push(new THREE.Vector3(r * Math.cos(t), r * Math.sin(t), (Math.random()-0.5)*20));
            }
            break;
        case 'Saturn':
             for (let i = 0; i < count; i++) {
                // 本体球体
                if (i < count * 0.4) {
                     const vec = new THREE.Vector3();
                     vec.randomDirection().multiplyScalar(Math.random() * 80);
                     points.push(vec);
                } else {
                    // 光环圆盘
                    const t = (i / (count * 0.6)) * Math.PI * 2 * 3; // 多绕几圈
                    const r = 120 + Math.random() * 60;
                    points.push(new THREE.Vector3(r * Math.cos(t), (Math.random()-0.5)*5, r * Math.sin(t)));
                }
            }
            break;
        case 'Fireworks':
             for (let i = 0; i < count; i++) {
                const vec = new THREE.Vector3();
                // 随机方向向外爆发
                vec.randomDirection().multiplyScalar(Math.random() * Math.random() * 250);
                points.push(vec);
            }
            break;
        case 'Galaxy':
        default:
             for (let i = 0; i < count; i++) {
                // 简易螺旋星系
                const t = (i / count) * Math.PI * 2 * 5; // 5圈螺旋
                const r = t * 8;
                const x = r * Math.cos(t);
                const y = (Math.random() - 0.5) * (r * 0.2); // 中心厚，边缘薄
                const z = r * Math.sin(t);
                points.push(new THREE.Vector3(x, y, z));
            }
            break;
    }
    return points;
}


// --- 4. UI 初始化 (lil-gui) ---
function initUI() {
    const gui = new lil.GUI({ title: '粒子控制面板' });
    gui.domElement.style.marginTop = "60px"; // 避开全屏按钮

    const folder1 = gui.addFolder('左手粒子 (系统1)');
    folder1.add(params, 'shape1', shapeOptions).name('模型形状').onChange(val => {
        updateParticleShape(particleSystem1, val);
    });
    folder1.addColor(params, 'color1').name('颜色').onChange(val => {
        particleSystem1.material.color.set(val);
    });

    const folder2 = gui.addFolder('右手粒子 (系统2)');
    folder2.add(params, 'shape2', shapeOptions).name('模型形状').onChange(val => {
        updateParticleShape(particleSystem2, val);
    });
    folder2.addColor(params, 'color2').name('颜色').onChange(val => {
        particleSystem2.material.color.set(val);
    });
    
    // 默认展开
    folder1.open();
    folder2.open();
}


// --- 5. MediaPipe Hands 集成 ---
function initMediaPipe() {
    const videoElement = document.getElementsByClassName('input_video')[0];
    const canvasElement = document.getElementsByClassName('output_canvas')[0];
    const canvasCtx = canvasElement.getContext('2d');

    function onResults(results) {
        // 隐藏加载提示
        document.getElementById('loading').style.display = 'none';
        handResults = results; // 保存结果供主循环使用
    }

    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});
    hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });
    hands.onResults(onResults);

    const camera = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 640,
        height: 360
    });
    camera.start();
}


// --- 6. 主循环与手势计算 ---

// 计算手掌张开程度的辅助函数
// 原理：计算所有指尖关键点到手腕关键点的平均距离，并除以手掌参考大小进行标准化。
function calculateHandOpenness(landmarks) {
    const wrist = landmarks[0];
    // 使用中指指根到手腕的距离作为手掌大小的参考
    const palmSizeRef = distance(wrist, landmarks[9]); 
    
    const fingertips = [4, 8, 12, 16, 20]; // 拇指、食指、中指、无名指、小指尖
    let totalDist = 0;
    fingertips.forEach(tipIdx => {
        totalDist += distance(wrist, landmarks[tipIdx]);
    });
    const avgDist = totalDist / fingertips.length;

    // 标准化：通常张开时 avgDist 约为 palmSizeRef 的 2.5 倍左右，握拳时约为 1.0 倍左右
    // 将其映射到 0 (握拳) 到 1 (张开) 的范围
    let openness = (avgDist / palmSizeRef - 1.0) / 1.5;
    return THREE.MathUtils.clamp(openness, 0, 1);
}

// 简单的 2D 距离计算
function distance(p1, p2) {
    return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
}

function animate() {
    requestAnimationFrame(animate);

    // 处理手势数据
    if (handResults && handResults.multiHandLandmarks) {
        let leftHandFound = false;
        let rightHandFound = false;

        for (let i = 0; i < handResults.multiHandLandmarks.length; i++) {
            const landmarks = handResults.multiHandLandmarks[i];
            // MediaPipe 的 'Left' 在镜像视频中通常对应用户的右手，这里需要根据实际情况调整
            // 我们这里假设摄像头的 label 是准确的，如果发现反了，互换一下即可。
            const label = handResults.multiHandedness[i].label; 
            
            const openness = calculateHandOpenness(landmarks);

            if (label === 'Left') {
                // 使用平滑插值让数值变化更稳定
                handState.leftHandOpenness = THREE.MathUtils.lerp(handState.leftHandOpenness, openness, 0.2);
                leftHandFound = true;
            } else if (label === 'Right') {
                 handState.rightHandOpenness = THREE.MathUtils.lerp(handState.rightHandOpenness, openness, 0.2);
                rightHandFound = true;
            }
        }

        // 如果手移出了画面，缓慢恢复到半张开状态
        if (!leftHandFound) handState.leftHandOpenness = THREE.MathUtils.lerp(handState.leftHandOpenness, 0.5, 0.05);
        if (!rightHandFound) handState.rightHandOpenness = THREE.MathUtils.lerp(handState.rightHandOpenness, 0.5, 0.05);
    }

    // 根据手势更新粒子系统状态
    // 左手控制系统1，右手控制系统2
    updateSystemByHand(particleSystem1, handState.leftHandOpenness);
    updateSystemByHand(particleSystem2, handState.rightHandOpenness);

    controls.update();
    renderer.render(scene, camera);
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

</script>
</body>
</html>
