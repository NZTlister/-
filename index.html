<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galaxy Particle Engine V3</title>
    <style>
        :root {
            --glass-bg: rgba(20, 20, 35, 0.4);
            --glass-border: rgba(255, 255, 255, 0.15);
            --primary: #00f2ff;
            --secondary: #bd00ff;
        }
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        
        /* æ²‰æµ¸å¼èƒŒæ™¯ */
        #canvas-container { 
            width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; 
            background: radial-gradient(circle at center, #11111f 0%, #000000 100%); 
        }

        /* æ‘„åƒå¤´æ‚¬æµ®çª— */
        #camera-wrapper {
            position: absolute; top: 20px; right: 20px; width: 180px; height: 135px;
            z-index: 10; border-radius: 12px; overflow: hidden;
            border: 1px solid rgba(255,255,255,0.2);
            background: #000;
            box-shadow: 0 0 20px rgba(0,242,255,0.1);
        }
        #video-input { 
            width: 100%; height: 100%; object-fit: cover; 
            transform: scaleX(-1); /* é•œåƒ */
        }
        /* è¯†åˆ«çŠ¶æ€æŒ‡ç¤ºç¯ */
        #cam-status {
            position: absolute; top: 10px; right: 10px; width: 10px; height: 10px;
            border-radius: 50%; background: red; z-index: 12;
            box-shadow: 0 0 10px red; transition: 0.3s;
        }
        #cam-status.active { background: #00f2ff; box-shadow: 0 0 10px #00f2ff; }

        /* åº•éƒ¨æ§åˆ¶æ  */
        #ui-panel {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            z-index: 10; padding: 10px 20px; border-radius: 50px;
            display: flex; gap: 15px; align-items: center;
            background: var(--glass-bg); backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }
        
        .btn {
            background: transparent; border: 1px solid rgba(255,255,255,0.1);
            color: rgba(255,255,255,0.7); padding: 8px 20px; border-radius: 25px;
            cursor: pointer; transition: all 0.3s; font-size: 14px;
            text-transform: uppercase; letter-spacing: 1px;
        }
        .btn:hover { background: rgba(255,255,255,0.1); color: white; transform: translateY(-2px); }
        .btn.active { 
            background: linear-gradient(45deg, var(--secondary), var(--primary)); 
            border: none; color: white; box-shadow: 0 0 20px rgba(189,0,255,0.4); 
        }

        #status-text {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);
            color: rgba(255,255,255,0.8); pointer-events: none; text-align: center;
            font-size: 14px; letter-spacing: 2px; text-shadow: 0 0 10px cyan;
        }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="canvas-container"></div>
    
    <div id="camera-wrapper">
        <div id="cam-status"></div>
        <video id="video-input" playsinline></video>
    </div>

    <div id="status-text">åˆå§‹åŒ–ç¥ç»ç½‘ç»œ...<br>è¯·å…è®¸æ‘„åƒå¤´æƒé™</div>

    <div id="ui-panel">
        <button class="btn active" onclick="setShape('galaxy')">ğŸŒŒ æ˜Ÿäº‘</button>
        <button class="btn" onclick="setShape('heart')">â¤ æ ¸å¿ƒ</button>
        <button class="btn" onclick="setShape('dna')">ğŸ§¬ åŒèºæ—‹</button>
        <button class="btn" onclick="setShape('sphere')">ğŸ”® èƒ½é‡çƒ</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- 1. åœºæ™¯ä¸è§†è§‰é…ç½® ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        // æ·»åŠ ä¸€ç‚¹èƒŒæ™¯é›¾ï¼Œå¢åŠ æ·±é‚ƒæ„Ÿ
        scene.fog = new THREE.FogExp2(0x050510, 0.002);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 5000);
        camera.position.z = 100;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;

        // --- 2. ç»ˆæç²’å­ç³»ç»Ÿ (Shader Pro) ---
        const PARTICLE_COUNT = 50000;
        const geometry = new THREE.BufferGeometry();
        
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const targets = new Float32Array(PARTICLE_COUNT * 3);
        const randoms = new Float32Array(PARTICLE_COUNT * 3);
        const colors = new Float32Array(PARTICLE_COUNT * 3);
        const sizes = new Float32Array(PARTICLE_COUNT);

        const color1 = new THREE.Color('#00f2ff'); // é’è‰²
        const color2 = new THREE.Color('#bd00ff'); // ç´«è‰²
        const color3 = new THREE.Color('#ffffff'); // æ ¸å¿ƒç™½

        for(let i=0; i<PARTICLE_COUNT; i++) {
            const i3 = i * 3;
            // åˆå§‹éšæœºåˆ†å¸ƒ
            positions[i3] = (Math.random()-0.5) * 500;
            positions[i3+1] = (Math.random()-0.5) * 500;
            positions[i3+2] = (Math.random()-0.5) * 500;
            
            randoms[i3] = Math.random();
            randoms[i3+1] = Math.random();
            randoms[i3+2] = Math.random();
            
            // éšæœºå¤§å°
            sizes[i] = Math.random();
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('target', new THREE.BufferAttribute(targets, 3));
        geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 3));
        geometry.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1));
        // Color attribute å°†åœ¨å½¢çŠ¶ç”Ÿæˆæ—¶è®¡ç®—ï¼Œä»¥å®ç°æ¸å˜

        // é«˜çº§ç€è‰²å™¨
        const material = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uMorph: { value: 0 },
                // äº¤äº’ Uniforms
                uScale: { value: 1.0 },
                uExplode: { value: 0.0 },
                uRotZ: { value: 0.0 }, // æ–¹å‘ç›˜å€¾æ–œ
                uCenterX: { value: 0.0 }, // å¹³ç§»
                uCenterY: { value: 0.0 }
            },
            vertexShader: `
                uniform float uTime;
                uniform float uMorph;
                uniform float uScale;
                uniform float uExplode;
                uniform float uRotZ;
                uniform float uCenterX;
                uniform float uCenterY;
                
                attribute vec3 target;
                attribute vec3 aRandom;
                attribute float aSize;
                attribute vec3 color; // é¡¶ç‚¹é¢œè‰²
                
                varying vec3 vColor;
                varying float vAlpha;

                // 2D æ—‹è½¬çŸ©é˜µ
                mat2 rotate(float angle) {
                    float s = sin(angle);
                    float c = cos(angle);
                    return mat2(c, -s, s, c);
                }

                void main() {
                    vColor = color;

                    // 1. å½¢çŠ¶ Morphing
                    vec3 pos = mix(position, target, uMorph);
                    
                    // 2. æ˜Ÿäº‘æµä½“è¿åŠ¨ (Curl Noise ç®€åŒ–ç‰ˆ)
                    float t = uTime * 0.5;
                    pos.x += sin(t + pos.y * 0.05) * 0.5;
                    pos.y += cos(t + pos.x * 0.05) * 0.5;
                    pos.z += sin(t * 1.2 + pos.x * 0.02) * 1.5; // Zè½´èµ·ä¼å¤§ä¸€ç‚¹

                    // 3. äº¤äº’ï¼šåŒæ‰‹æ§åˆ¶ç¼©æ”¾
                    pos *= uScale;

                    // 4. äº¤äº’ï¼šæåˆç‚¸è£‚ (æ²¿ç€æ³•çº¿å‘å¤–)
                    vec3 explodeDir = normalize(pos);
                    pos += explodeDir * uExplode * 80.0;

                    // 5. äº¤äº’ï¼šæ–¹å‘ç›˜ Zè½´æ—‹è½¬ (å·¦å³æ‰‹é«˜ä½)
                    pos.xy = rotate(uRotZ) * pos.xy;
                    
                    // 6. äº¤äº’ï¼šå¹³ç§»è·Ÿéš
                    pos.x += uCenterX * 50.0;
                    pos.y += uCenterY * 50.0;

                    // è½¬æ¢åæ ‡
                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    gl_Position = projectionMatrix * mvPosition;

                    // å¤§å°è¡°å‡ï¼šè¿‘å¤§è¿œå° + å‘¼å¸é—ªçƒ
                    float blink = 0.8 + 0.2 * sin(uTime * 3.0 + aRandom.x * 10.0);
                    gl_PointSize = (4.0 * aSize + 1.0) * blink * uScale * (80.0 / -mvPosition.z);
                    
                    // è¿œå¤„ç²’å­å˜æ·¡
                    vAlpha = smoothstep(200.0, 0.0, -mvPosition.z) * 0.8 + 0.2;
                }
            `,
            fragmentShader: `
                varying vec3 vColor;
                varying float vAlpha;

                void main() {
                    // ç»˜åˆ¶æŸ”å’Œçš„å…‰ç‚¹
                    vec2 uv = gl_PointCoord.xy - 0.5;
                    float dist = length(uv);
                    if (dist > 0.5) discard;

                    // æ ¸å¿ƒé«˜äº®ï¼Œè¾¹ç¼˜å‘å…‰
                    float strength = 0.05 / (dist * dist + 0.001); // ç‰©ç†å…‰æ™•è¡°å‡
                    strength = pow(strength, 1.2);
                    strength = clamp(strength, 0.0, 1.0);

                    vec3 finalColor = vColor * strength;
                    // å¢åŠ ä¸€ç‚¹è¿‡æ›çš„ç™½è‰²æ ¸å¿ƒ
                    finalColor = mix(finalColor, vec3(1.0), strength * 0.5 * step(0.1, 1.0-dist*2.0));

                    gl_FragColor = vec4(finalColor, vAlpha * strength);
                }
            `,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending,
            vertexColors: true // å¼€å¯é¡¶ç‚¹é¢œè‰²
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- 3. å¤æ‚å½¢çŠ¶ç®—æ³• ---
        
        // è¾…åŠ©ï¼šè®¾ç½®é¢œè‰² buffer
        const colorAttr = new THREE.BufferAttribute(colors, 3);
        geometry.setAttribute('color', colorAttr);

        const shapes = {
            galaxy: (i) => {
                // èºæ—‹æ˜Ÿç³»ç®—æ³•
                const branches = 5; // æ—‹è‡‚æ•°é‡
                const spin = i % branches;
                const radius = Math.pow(Math.random(), 1.5) * 60; // æ ¸å¿ƒå¯†é›†ï¼Œå¤–å›´ç¨€ç–
                const angle = spin * (Math.PI * 2 / branches) + (radius * 0.05); // éšåŠå¾„æ‰­æ›²
                
                const randomOffset = Math.random() - 0.5;
                const x = Math.cos(angle) * radius + randomOffset * (radius * 0.2);
                const z = Math.sin(angle) * radius + randomOffset * (radius * 0.2);
                const y = (Math.random() - 0.5) * (Math.exp(-radius * 0.05) * 20); // æ ¸å¿ƒåšï¼Œè¾¹ç¼˜è–„

                // é¢œè‰²è®¡ç®—ï¼šæ ¸å¿ƒç™½/é’ï¼Œè¾¹ç¼˜ç´«
                const colorMix = Math.min(radius / 50, 1.0);
                const c = new THREE.Color().lerpColors(color1, color2, colorMix);
                if(radius < 10) c.lerp(color3, 0.8); // æ ¸å¿ƒäº®ç™½
                
                colorAttr.setXYZ(i, c.r, c.g, c.b);
                return new THREE.Vector3(x, y, z);
            },
            heart: (i) => {
                const phi = Math.random() * Math.PI * 2;
                const theta = Math.random() * Math.PI;
                // 3D å¿ƒå½¢
                let x = 16 * Math.pow(Math.sin(theta), 3) * Math.cos(phi);
                let y = 13 * Math.cos(theta) - 5 * Math.cos(2*theta) - 2 * Math.cos(3*theta) - Math.cos(4*theta);
                let z = 16 * Math.pow(Math.sin(theta), 3) * Math.sin(phi) * 0.8;
                
                // é¢œè‰²ï¼šçº¢è‰²ç³»
                const c = new THREE.Color('#ff0055').lerp(new THREE.Color('#ff99aa'), Math.random());
                colorAttr.setXYZ(i, c.r, c.g, c.b);
                
                return new THREE.Vector3(x, y, z).multiplyScalar(1.5);
            },
            dna: (i, total) => {
                // åŒèºæ—‹ DNA
                const len = 80;
                const radius = 10;
                const turns = 4;
                
                // å°†ç²’å­åˆ†ä¸ºä¸¤è‚¡
                const strand = i % 2 === 0 ? 1 : -1;
                const progress = i / total; // 0 ~ 1
                
                const angle = progress * Math.PI * 2 * turns;
                const x = Math.cos(angle) * radius * strand;
                const z = Math.sin(angle) * radius * strand;
                const y = (progress - 0.5) * len;

                // å¢åŠ ä¸€äº›éšæœºæ•£é€¸
                const v = new THREE.Vector3(x, y, z);
                v.addScaledVector(new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5), 2.0);

                // é¢œè‰²ï¼šè“ç»¿åŒºåˆ†
                const c = strand === 1 ? new THREE.Color('#00ff88') : new THREE.Color('#0088ff');
                colorAttr.setXYZ(i, c.r, c.g, c.b);
                return v;
            },
            sphere: (i) => {
                const r = 40 * Math.cbrt(Math.random()); // å‡åŒ€å¡«å……çƒä½“
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi);

                // é¢œè‰²ï¼šç”µæµ†è‰²
                const c = new THREE.Color('#ffaa00').lerp(new THREE.Color('#ff0000'), Math.random());
                colorAttr.setXYZ(i, c.r, c.g, c.b);
                return new THREE.Vector3(x, y, z);
            }
        };

        let animateMorph = true;
        window.setShape = (name) => {
            document.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
            event.currentTarget.classList.add('active');
            
            const targetAttr = geometry.attributes.target;
            for(let i=0; i<PARTICLE_COUNT; i++) {
                const v = shapes[name](i, PARTICLE_COUNT);
                targetAttr.setXYZ(i, v.x, v.y, v.z);
            }
            targetAttr.needsUpdate = true;
            colorAttr.needsUpdate = true; // é¢œè‰²ä¹Ÿè¦æ›´æ–°
            
            material.uniforms.uMorph.value = 0;
            animateMorph = true;
        };

        // åˆå§‹åŒ–
        window.setShape('galaxy');

        // --- 4. äº¤äº’é€»è¾‘ (AI æ ¸å¿ƒ) ---
        
        let targetScale = 1.0;
        let targetExplode = 0.0;
        let targetRotZ = 0.0;
        let targetCenterX = 0.0;
        let targetCenterY = 0.0;

        function onResults(results) {
            const hands = results.multiHandLandmarks;
            const statusDiv = document.getElementById('status-text');
            const indicator = document.getElementById('cam-status');

            if (hands.length > 0) {
                indicator.classList.add('active');
                statusDiv.style.opacity = 0;
            } else {
                indicator.classList.remove('active');
            }

            if (hands.length === 2) {
                // === åŒæ‰‹æ¨¡å¼ï¼šå…¨èƒ½æ“æ§ ===
                const h1 = hands[0][9]; // å·¦æ‰‹ä¸­æŒ‡æ ¹éƒ¨ (è¾ƒç¨³å®š)
                const h2 = hands[1][9]; // å³æ‰‹ä¸­æŒ‡æ ¹éƒ¨

                // 1. è·ç¦»æ§åˆ¶å¤§å°
                // åŒæ ·ä½¿ç”¨ 3D è·ç¦»
                const dist = Math.hypot(h1.x - h2.x, h1.y - h2.y);
                // æ˜ å°„ï¼šæ‰‹è¿‘(0.1) -> å°(0.5å€), æ‰‹è¿œ(0.6) -> å¤§(2.0å€)
                targetScale = THREE.MathUtils.mapLinear(dist, 0.15, 0.6, 0.5, 2.5);
                targetScale = THREE.MathUtils.clamp(targetScale, 0.4, 3.0);

                // 2. "æ–¹å‘ç›˜" å€¾æ–œæ§åˆ¶ Zè½´æ—‹è½¬
                // è®¡ç®—ä¸¤æ‰‹è¿çº¿çš„æ–œç‡è§’åº¦
                const dx = h2.x - h1.x;
                const dy = h2.y - h1.y;
                // atan2 è¿”å›å¼§åº¦ -PI ~ PI
                // æˆ‘ä»¬å¸Œæœ›å·¦æ‰‹é«˜(yå°)æ—¶é€†æ—¶é’ˆè½¬ï¼Œæ‰€ä»¥å–è´Ÿ
                let angle = Math.atan2(dy, dx); 
                
                // MediaPipe çš„åæ ‡ç³» Y æ˜¯å‘ä¸‹çš„ï¼Œæ‰€ä»¥éœ€è¦ç¨å¾®åè½¬ä¸€ä¸‹é€»è¾‘
                // æ­£å¸¸æ°´å¹³æ—¶ angle æ¥è¿‘ 0 (å¦‚æœh1åœ¨å·¦) æˆ– PI (å¦‚æœh1åœ¨å³)
                // è¿™æ˜¯ä¸€ä¸ªç®€åŒ–ç‰ˆçš„ steering é€»è¾‘
                targetRotZ = -angle * 1.5; // å¢åŠ ä¸€ç‚¹çµæ•åº¦

                // 3. åŒæ‰‹ä¸­å¿ƒç‚¹å¹³ç§»
                const cx = (h1.x + h2.x) / 2;
                const cy = (h1.y + h2.y) / 2;
                // æ˜ å°„ 0~1 åˆ° -1~1
                targetCenterX = -(cx - 0.5) * 3.0; // åå‘ç§»åŠ¨æ›´æœ‰æ“æ§æ„Ÿ
                targetCenterY = -(cy - 0.5) * 3.0;

                targetExplode = 0.0;
                controls.autoRotate = false; // æ‰‹åŠ¨æ§åˆ¶æ—¶åœæ­¢è‡ªåŠ¨æ—‹è½¬

            } else if (hands.length === 1) {
                // === å•æ‰‹æ¨¡å¼ï¼šèƒ½é‡é‡Šæ”¾ ===
                const h = hands[0];
                const thumb = h[4];
                const index = h[8];
                const pinch = Math.hypot(thumb.x - index.x, thumb.y - index.y);

                // æåˆï¼šå‡èšï¼›å¼ å¼€ï¼šç‚¸è£‚
                if (pinch > 0.12) {
                    targetExplode = (pinch - 0.12) * 6.0;
                } else {
                    targetExplode = 0.0;
                }
                
                // å•æ‰‹æ—¶ç¼“æ…¢å›æ­£
                targetRotZ *= 0.9;
                targetCenterX *= 0.9;
                targetCenterY *= 0.9;
                controls.autoRotate = true;
            } else {
                // æ— æ‰‹åŠ¿ï¼šè‡ªåŠ¨å·¡èˆª
                targetScale = 1.0;
                targetExplode = 0.0;
                targetRotZ *= 0.95; // æƒ¯æ€§å›æ­£
                targetCenterX *= 0.95;
                targetCenterY *= 0.95;
                controls.autoRotate = true;
            }
        }

        // å¯åŠ¨ AI
        const videoElement = document.getElementById('video-input');
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);
        
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 320, height: 240
        });
        cameraUtils.start();


        // --- 5. æ¸²æŸ“å¾ªç¯ ---
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            const time = clock.getElapsedTime();

            material.uniforms.uTime.value = time;

            // ç‰©ç†å¹³æ»‘ç®—æ³• (Lerp)
            const s = 0.1; // é˜»å°¼ç³»æ•°
            material.uniforms.uScale.value += (targetScale - material.uniforms.uScale.value) * s;
            material.uniforms.uExplode.value += (targetExplode - material.uniforms.uExplode.value) * s;
            material.uniforms.uRotZ.value += (targetRotZ - material.uniforms.uRotZ.value) * 0.08; // æ—‹è½¬ç¨å¾®æ…¢ç‚¹æ›´æœ‰æƒ¯æ€§
            material.uniforms.uCenterX.value += (targetCenterX - material.uniforms.uCenterX.value) * s;
            material.uniforms.uCenterY.value += (targetCenterY - material.uniforms.uCenterY.value) * s;

            // å½¢çŠ¶å˜å½¢åŠ¨ç”»
            if (animateMorph) {
                material.uniforms.uMorph.value += dt * 0.6;
                if (material.uniforms.uMorph.value >= 1.0) {
                    material.uniforms.uMorph.value = 1.0;
                    animateMorph = false;
                    const p = geometry.attributes.position.array;
                    const t = geometry.attributes.target.array;
                    for(let i=0; i<p.length; i++) p[i] = t[i];
                    geometry.attributes.position.needsUpdate = true;
                    material.uniforms.uMorph.value = 0.0;
                }
            }

            controls.update();
            renderer.render(scene, camera);
        }

        animate();
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
