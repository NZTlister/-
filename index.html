<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Gesture Controlled Romantic Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        
        /* è§†é¢‘éšè—ï¼Œåªç”¨äºè¯†åˆ« */
        #video-input { position: absolute; top: 0; left: 0; opacity: 0; pointer-events: none; z-index: -1; }
        
        /* å…¨å±Canvas */
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }

        /* UI é¢æ¿ */
        #ui-panel {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 15px 25px;
            border-radius: 30px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            gap: 15px;
            align-items: center;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            transition: all 0.3s ease;
        }

        #ui-panel:hover { background: rgba(255, 255, 255, 0.15); box-shadow: 0 0 30px rgba(255,105,180, 0.3); }

        .btn {
            background: transparent;
            border: 1px solid rgba(255,255,255,0.4);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            transition: 0.3s;
            font-size: 14px;
        }

        .btn:hover, .btn.active { background: rgba(255, 255, 255, 0.9); color: #000; }
        
        /* é¢œè‰²é€‰æ‹©å™¨ç¾åŒ– */
        input[type="color"] {
            border: none; width: 32px; height: 32px; cursor: pointer; background: none; padding: 0;
        }
        
        /* å…¨å±æŒ‰é’® */
        #fs-btn { position: absolute; top: 20px; right: 20px; z-index: 10; font-size: 20px; background: none; border: none; color: white; cursor: pointer; opacity: 0.7; }
        #fs-btn:hover { opacity: 1; text-shadow: 0 0 10px white; }

        /* åŠ è½½æç¤º */
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; z-index: 20; font-size: 24px; letter-spacing: 2px;
            text-shadow: 0 0 10px cyan; pointer-events: none;
        }
    </style>
</head>
<body>

    <video id="video-input"></video>
    
    <div id="canvas-container"></div>
    
    <div id="loading">æ­£åœ¨åˆå§‹åŒ–è§†è§‰æ ¸å¿ƒ... è¯·æˆäºˆæ‘„åƒå¤´æƒé™</div>

    <button id="fs-btn">â›¶</button>

    <div id="ui-panel">
        <button class="btn active" onclick="setShape('heart')">â¤ çˆ±å¿ƒ</button>
        <button class="btn" onclick="setShape('galaxy')">ğŸŒŒ æ˜Ÿç³»</button>
        <button class="btn" onclick="setShape('saturn')">ğŸª åœŸæ˜Ÿ</button>
        <button class="btn" onclick="setShape('flower')">â€ èŠ±æœµ</button>
        <div style="width:1px; height:20px; background:rgba(255,255,255,0.3)"></div>
        <input type="color" id="color-picker" value="#ff69b4" title="ç²’å­é¢œè‰²">
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/hands": "https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js",
                "@mediapipe/camera_utils": "https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- 1. åˆå§‹åŒ–åœºæ™¯ ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02); // å¢åŠ æ·±é‚ƒæ„Ÿ

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 40;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;

        // --- 2. ç²’å­ç³»ç»Ÿ (åŸºäº Shader) ---
        const PARTICLE_COUNT = 30000;
        const geometry = new THREE.BufferGeometry();
        
        // å±æ€§æ•°ç»„
        const positions = new Float32Array(PARTICLE_COUNT * 3); // å½“å‰ä½ç½®
        const targets = new Float32Array(PARTICLE_COUNT * 3);   // ç›®æ ‡å½¢çŠ¶ä½ç½®
        const randoms = new Float32Array(PARTICLE_COUNT * 3);   // éšæœºå› å­ï¼ˆç”¨äºå™ªå£°ï¼‰
        
        for(let i=0; i<PARTICLE_COUNT * 3; i++) {
            positions[i] = (Math.random() - 0.5) * 100; // åˆå§‹éšæœºåˆ†å¸ƒ
            randoms[i] = Math.random();
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('target', new THREE.BufferAttribute(targets, 3));
        geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 3));

        // Shader æè´¨ï¼šå®ç°æµªæ¼«çš„å…‰æ™•å’Œå˜å½¢
        const material = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uColor: { value: new THREE.Color('#ff69b4') },
                uMorph: { value: 0 }, // 0 = ä¿æŒå½“å‰ï¼Œ1 = å˜ä¸ºç›®æ ‡
                uHandScale: { value: 1.0 }, // æ‰‹åŠ¿æ§åˆ¶ç¼©æ”¾
                uHandDisplace: { value: 0.0 }, // æ‰‹åŠ¿æ§åˆ¶æ‰©æ•£
                uMouse: { value: new THREE.Vector3(0,0,0) }
            },
            vertexShader: `
                uniform float uTime;
                uniform float uMorph;
                uniform float uHandScale;
                uniform float uHandDisplace;
                
                attribute vec3 target;
                attribute vec3 aRandom;
                
                varying float vAlpha;

                // ç®€å•çš„å™ªå£°å‡½æ•°
                float random(vec2 st) {
                    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
                }

                void main() {
                    // 1. æ··åˆå½“å‰ä½ç½®ä¸ç›®æ ‡å½¢çŠ¶ (Lerp)
                    // åœ¨CPUç«¯æˆ‘ä»¬å®é™…ä¸Šæ˜¯ç›´æ¥æ›´æ–°Attributeï¼Œè¿™é‡Œä¸»è¦å¤„ç†å¾®åŠ¨æ•ˆ
                    vec3 pos = mix(position, target, uMorph);
                    
                    // 2. æ·»åŠ "å‘¼å¸"å’Œ"æ¼‚æµ®"æ•ˆæœ (æµªæ¼«æ„Ÿ)
                    float noise = sin(uTime * 2.0 + aRandom.x * 10.0) * 0.2;
                    pos += normalize(pos) * noise;

                    // 3. æ‰‹åŠ¿æ§åˆ¶ï¼šæ•´ä½“ç¼©æ”¾
                    pos *= uHandScale;

                    // 4. æ‰‹åŠ¿æ§åˆ¶ï¼šç‚¸è£‚/æ‰©æ•£æ•ˆæœ (åŸºäºéšæœºæ–¹å‘)
                    vec3 explosion = normalize(pos) * uHandDisplace * 20.0;
                    pos += explosion;

                    // 5. æ—‹è½¬æ•ˆæœ (ä¸ºäº†çœ‹èµ·æ¥æ›´çµåŠ¨)
                    float angle = uTime * 0.1 * (1.0 - aRandom.y);
                    float s = sin(angle);
                    float c = cos(angle);
                    // ç®€å•çš„Yè½´æ—‹è½¬çŸ©é˜µ
                    mat2 rot = mat2(c, -s, s, c);
                    pos.xz = rot * pos.xz;

                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    
                    // ç²’å­å¤§å°éšè·ç¦»å˜åŒ–
                    gl_PointSize = (4.0 * uHandScale + noise * 2.0) * (30.0 / -mvPosition.z);
                    
                    gl_Position = projectionMatrix * mvPosition;
                    
                    // è¾¹ç¼˜ç²’å­é€æ˜åº¦ä½
                    vAlpha = 0.8 + noise * 0.2;
                }
            `,
            fragmentShader: `
                uniform vec3 uColor;
                varying float vAlpha;

                void main() {
                    // ç»˜åˆ¶åœ†å½¢ç²’å­
                    vec2 coord = gl_PointCoord - vec2(0.5);
                    float dist = length(coord);
                    if (dist > 0.5) discard;

                    // å¾„å‘æ¸å˜ï¼Œåˆ¶é€ å‘å…‰æ„Ÿ
                    float glow = 1.0 - (dist * 2.0);
                    glow = pow(glow, 1.5); 

                    gl_FragColor = vec4(uColor, vAlpha * glow);
                }
            `,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending // å…³é”®ï¼šåŠ æ³•æ··åˆè®©ç²’å­é‡å å¤„å‘å…‰
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- 3. å½¢çŠ¶ç”Ÿæˆæ•°å­¦å…¬å¼ ---
        
        function getPointOnHeart(t) {
            // 3D å¿ƒå½¢å…¬å¼
            const x = 16 * Math.pow(Math.sin(t), 3);
            const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
            const z = 1; 
            return new THREE.Vector3(x, y, z);
        }

        const shapes = {
            heart: (i) => {
                // ä½¿ç”¨å‚æ•°æ–¹ç¨‹å¡«å……
                // ä¸ºäº†è®©å¿ƒå½¢ç«‹ä½“ï¼Œæˆ‘ä»¬æ·»åŠ ä¸€äº›éšæœºçš„Zæ·±åº¦å’Œå†…éƒ¨å¡«å……
                const phi = Math.random() * Math.PI * 2;
                const theta = Math.random() * Math.PI;
                // åŸºæœ¬å¿ƒå½¢è½®å»“
                let x = 16 * Math.pow(Math.sin(theta), 3) * Math.cos(phi);
                let y = 13 * Math.cos(theta) - 5 * Math.cos(2*theta) - 2 * Math.cos(3*theta) - Math.cos(4*theta);
                let z = 16 * Math.pow(Math.sin(theta), 3) * Math.sin(phi) * 0.5; // å‹æ‰ä¸€ç‚¹zè½´
                return new THREE.Vector3(x, y, z).multiplyScalar(0.8);
            },
            galaxy: (i) => {
                // èºæ—‹æ˜Ÿç³»
                const branchAngle = (i % 3) * ((2 * Math.PI) / 3);
                const radius = Math.random() * 30;
                const spinAngle = radius * 0.5; // è¶Šè¿œè½¬å¾—è¶Šå¤š
                
                const randomX = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1) * 2;
                const randomY = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1) * 2;
                const randomZ = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1) * 2;

                const x = Math.cos(branchAngle + spinAngle) * radius + randomX;
                const y = randomY * 2; // æ‰å¹³
                const z = Math.sin(branchAngle + spinAngle) * radius + randomZ;
                return new THREE.Vector3(x, y, z);
            },
            saturn: (i) => {
                // æ˜Ÿçƒ + ç¯
                if (i < PARTICLE_COUNT * 0.7) {
                    // æ˜Ÿçƒæœ¬ä½“
                    const r = 8;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos((Math.random() * 2) - 1);
                    const x = r * Math.sin(phi) * Math.cos(theta);
                    const y = r * Math.sin(phi) * Math.sin(theta);
                    const z = r * Math.cos(phi);
                    return new THREE.Vector3(x, y, z);
                } else {
                    // ç¯
                    const angle = Math.random() * Math.PI * 2;
                    const r = 12 + Math.random() * 10;
                    const x = Math.cos(angle) * r;
                    const z = Math.sin(angle) * r;
                    const y = (Math.random() - 0.5) * 0.5;
                    return new THREE.Vector3(x, y, z);
                }
            },
            flower: (i) => {
                // ç®€å•çš„èŠ±æœµå½¢çŠ¶ (ç«ç‘°æ›²çº¿å˜ä½“)
                const u = Math.random() * Math.PI * 4; // è§’åº¦
                const v = Math.random() * 20; // åŠå¾„åˆ†å¸ƒ
                const k = 4; // èŠ±ç“£æ•°
                const r = Math.cos(k * u) * 15 + v * 0.5;
                const x = r * Math.cos(u);
                const y = r * Math.sin(u);
                const z = (Math.random() - 0.5) * 5 + Math.sin(v)*2;
                return new THREE.Vector3(x, y, z);
            }
        };

        // åˆ‡æ¢å½¢çŠ¶é€»è¾‘
        let currentShape = 'heart';
        window.setShape = (shapeName) => {
            currentShape = shapeName;
            
            // UI æ›´æ–°
            document.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');

            // é‡æ–°è®¡ç®—ç›®æ ‡ä½ç½®
            const targetAttr = geometry.attributes.target;
            for(let i=0; i<PARTICLE_COUNT; i++) {
                const vec = shapes[shapeName](i);
                targetAttr.setXYZ(i, vec.x, vec.y, vec.z);
            }
            targetAttr.needsUpdate = true;
            
            // é‡ç½®å˜å½¢è¿›åº¦
            material.uniforms.uMorph.value = 0;
            animateMorph = true;
        };

        // åˆå§‹åŒ–ç¬¬ä¸€æ¬¡å½¢çŠ¶
        const targetAttr = geometry.attributes.target;
        for(let i=0; i<PARTICLE_COUNT; i++) {
            const vec = shapes.heart(i);
            targetAttr.setXYZ(i, vec.x, vec.y, vec.z);
        }
        targetAttr.needsUpdate = true;

        // --- 4. æ‰‹åŠ¿è¯†åˆ«é€»è¾‘ (MediaPipe) ---
        
        let handScaleTarget = 1.0;
        let handDisplaceTarget = 0.0;
        let targetColor = new THREE.Color('#ff69b4');
        let isHandsDetected = false;

        async function initMediaPipe() {
            // åŠ¨æ€åŠ è½½ MediaPipe
            const { Hands } = window;
            const { Camera } = window;

            if(!Hands || !Camera) {
                console.error("MediaPipe libraries not loaded");
                return;
            }

            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onResults);

            const video = document.getElementById('video-input');
            const camera = new Camera(video, {
                onFrame: async () => {
                    await hands.send({image: video});
                },
                width: 640,
                height: 480
            });
            camera.start()
                .then(() => document.getElementById('loading').style.display = 'none')
                .catch(e => document.getElementById('loading').innerText = 'æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥æƒé™');
        }

        function onResults(results) {
            isHandsDetected = results.multiHandLandmarks.length > 0;

            if (results.multiHandLandmarks.length === 2) {
                // --- åŒæ‰‹é€»è¾‘ ---
                const hand1 = results.multiHandLandmarks[0];
                const hand2 = results.multiHandLandmarks[1];

                // 1. è®¡ç®—ä¸¤æ‰‹è…•é—´è·ï¼Œæ§åˆ¶ç¼©æ”¾
                const wrist1 = hand1[0]; // 0 æ˜¯æ‰‹è…•ç‚¹
                const wrist2 = hand2[0];
                const distance = Math.sqrt(
                    Math.pow(wrist1.x - wrist2.x, 2) + 
                    Math.pow(wrist1.y - wrist2.y, 2)
                );
                
                // æ˜ å°„è·ç¦»åˆ°ç¼©æ”¾ (0.2 ~ 0.8 æ˜¯å¤§æ¦‚çš„å±å¹•å½’ä¸€åŒ–è·ç¦»)
                // è·ç¦»è¶Šè¿œï¼Œæ¨¡å‹è¶Šå¤§
                handScaleTarget = 0.5 + (distance * 3.0); 

                // 2. æ£€æµ‹"åè½¬"æ‰‹åŠ¿ (æ¯”å¦‚ä¸¤æ‰‹äº¤å‰)
                if (wrist1.x > wrist2.x) {
                     // æ­£å¸¸çŠ¶æ€ï¼Œå·¦æ‰‹åœ¨å·¦
                } else {
                    // äº¤å‰çŠ¶æ€ï¼Œè§¦å‘åè½¬æ—‹è½¬é€Ÿåº¦åŠ å¿«
                    controls.autoRotateSpeed = 10.0;
                }

            } else if (results.multiHandLandmarks.length === 1) {
                // --- å•æ‰‹é€»è¾‘ ---
                const hand = results.multiHandLandmarks[0];
                
                // è®¡ç®—é£ŸæŒ‡(8)å’Œæ‹‡æŒ‡(4)çš„è·ç¦» -> æ§åˆ¶ç²’å­æ‰©æ•£/å‡èš
                const thumb = hand[4];
                const index = hand[8];
                const pinchDist = Math.sqrt(
                    Math.pow(thumb.x - index.x, 2) + 
                    Math.pow(thumb.y - index.y, 2)
                );

                // å¼ å¼€æ‰‹(è·ç¦»å¤§) = ç²’å­æ‰©æ•£/çˆ†ç‚¸; æåˆ = ç²’å­å‡èš
                if (pinchDist > 0.1) {
                    handDisplaceTarget = (pinchDist - 0.1) * 5.0; // æ‰©æ•£åŠ›åº¦
                } else {
                    handDisplaceTarget = 0;
                }
                
                handScaleTarget = 1.0;
                controls.autoRotateSpeed = 2.0;
            } else {
                // æ— æ‰‹åŠ¿ï¼Œæ¢å¤é»˜è®¤
                handScaleTarget = 1.0;
                handDisplaceTarget = 0.0;
                controls.autoRotateSpeed = 0.5;
            }
        }

        // å»¶è¿ŸåŠ è½½ MediaPipe ä»¥é¿å…é˜»å¡é¡µé¢
        setTimeout(() => {
            // ç®€å•çš„ CDN æ£€æŸ¥è„šæœ¬
            const script = document.createElement('script');
            script.src = "https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js";
            script.onload = () => {
                 const camScript = document.createElement('script');
                 camScript.src = "https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js";
                 camScript.onload = initMediaPipe;
                 document.body.appendChild(camScript);
            };
            document.body.appendChild(script);
        }, 1000);


        // --- 5. äº¤äº’ä¸åŠ¨ç”»å¾ªç¯ ---
        
        // é¢œè‰²é€‰æ‹©å™¨
        const colorPicker = document.getElementById('color-picker');
        colorPicker.addEventListener('input', (e) => {
            targetColor.set(e.target.value);
        });

        // å…¨å±é€»è¾‘
        document.getElementById('fs-btn').addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        });

        let animateMorph = true;
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const dt = clock.getDelta();
            const time = clock.getElapsedTime();

            // 1. æ›´æ–° Uniforms
            material.uniforms.uTime.value = time;
            
            // é¢œè‰²å¹³æ»‘è¿‡æ¸¡
            material.uniforms.uColor.value.lerp(targetColor, 0.05);

            // æ‰‹åŠ¿æ•°å€¼å¹³æ»‘è¿‡æ¸¡ (Lerp)
            material.uniforms.uHandScale.value += (handScaleTarget - material.uniforms.uHandScale.value) * 0.1;
            material.uniforms.uHandDisplace.value += (handDisplaceTarget - material.uniforms.uHandDisplace.value) * 0.1;

            // å½¢çŠ¶å˜å½¢è¿‡æ¸¡ (ä»å½“å‰ä½ç½®åˆ° target)
            // è¿™é‡Œæˆ‘ä»¬ç”¨äº†ä¸€ä¸ªæŠ€å·§ï¼šæˆ‘ä»¬åœ¨shaderé‡Œåšmixï¼Œ
            // ä½†å¦‚æœä¸€ç›´åªæ”¹shaderï¼Œtargetä¸€æ—¦å˜äº†ä¼šç¬å˜ã€‚
            // çœŸæ­£çš„é…·ç‚«åšæ³•æ˜¯æ¯å¸§åœ¨JSé‡Œæ›´æ–°positionå±æ€§å‘targeté è¿‘ï¼ˆCPUå¼€é”€å¤§ï¼‰ï¼Œ
            // æˆ–è€…ä½¿ç”¨ä¸¤ä¸ªattribute bufferåšping-pongã€‚
            // ä¸ºäº†ç®€åŒ–ä¸”ä¿æŒé«˜æ€§èƒ½ï¼Œæˆ‘ä»¬ä½¿ç”¨Shaderé‡Œçš„uMorphæ§åˆ¶ï¼š
            // å½“ç‚¹å‡»æŒ‰é’®æ—¶ï¼ŒuMorphä»0å¢åŠ åˆ°1ã€‚å½“å®Œå…¨åˆ°è¾¾1æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨JSé‡ŒæŠŠpositionæ›´æ–°ä¸ºtargetï¼Œç„¶åé‡ç½®uMorphã€‚
            
            if (animateMorph) {
                material.uniforms.uMorph.value += dt * 0.8; // å˜å½¢é€Ÿåº¦
                if (material.uniforms.uMorph.value >= 1.0) {
                    material.uniforms.uMorph.value = 1.0;
                    animateMorph = false;
                    
                    // å°†å½“å‰çš„position bufferæ›´æ–°ä¸ºtargetçš„å†…å®¹ï¼Œä»¥ä¾¿ä¸‹æ¬¡å˜å½¢
                    // æ³¨æ„ï¼šè¿™æ­¥åœ¨å¤§é‡ç²’å­æ—¶å¯èƒ½ç•¥è€—æ—¶ï¼Œä½†åœ¨å˜å½¢ç»“æŸç¬é—´åšä¸€æ¬¡é€šå¸¸æ— æ„Ÿ
                    const posArr = geometry.attributes.position.array;
                    const targetArr = geometry.attributes.target.array;
                    for(let i=0; i<posArr.length; i++) {
                        posArr[i] = targetArr[i];
                    }
                    geometry.attributes.position.needsUpdate = true;
                    material.uniforms.uMorph.value = 0.0;
                }
            }

            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        // çª—å£è‡ªé€‚åº”
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
